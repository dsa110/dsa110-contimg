#!/bin/bash
set -e  # Exit on any error
# Pre-commit hook for test organization validation and code formatting
# This ensures all new/modified tests follow the organization rules
# and formats code with Prettier, Black, and isort

# ============================================================================
# 0. Environment Validation
# ============================================================================
# Verify casa6 Python environment exists and is accessible
if [ ! -x "/opt/miniforge/envs/casa6/bin/python" ]; then
    echo "ERROR: casa6 Python environment not found!" >&2
    echo "" >&2
    echo "The casa6 conda environment is required for this project." >&2
    echo "Expected path: /opt/miniforge/envs/casa6/bin/python" >&2
    echo "" >&2
    echo "Please ensure casa6 is installed and accessible." >&2
    echo "See: docs/CASA6_ENVIRONMENT_GUIDE.md" >&2
    exit 1
fi

# Clean up stale lock file if it exists and no process is using it
if [ -f ".git/index.lock" ]; then
    # Check if any process is using the lock file
    # Try lsof first (more reliable), fall back to fuser, then check process list
    LOCK_IN_USE=false
    
    if command -v lsof >/dev/null 2>&1; then
        if lsof ".git/index.lock" >/dev/null 2>&1; then
            LOCK_IN_USE=true
        fi
    elif command -v fuser >/dev/null 2>&1; then
        if fuser ".git/index.lock" >/dev/null 2>&1; then
            LOCK_IN_USE=true
        fi
    else
        # Fallback: check if any git process is running
        if ps aux | grep -E "[g]it|pre-commit" | grep -v "grep" >/dev/null 2>&1; then
            # Git process running - check lock file age
            # If lock is older than 5 minutes, it's likely stale
            if [ -f ".git/index.lock" ]; then
                LOCK_AGE=$(find .git/index.lock -mmin +5 2>/dev/null | wc -l)
                if [ "$LOCK_AGE" -gt 0 ]; then
                    LOCK_IN_USE=false  # Old lock (>5 min), likely stale
                else
                    LOCK_IN_USE=true   # Recent lock, might be in use
                fi
            fi
        fi
    fi
    
    if [ "$LOCK_IN_USE" = "true" ]; then
        echo "Error: Git lock file is in use by another process!" >&2
        echo "Please wait for the other git operation to complete." >&2
        echo "Or run: ./scripts/fix-git-lock.sh" >&2
        exit 1
    else
        echo "Warning: Removing stale git lock file..." >&2
        rm -f ".git/index.lock"
    fi
fi

# Get all staged files once (used by multiple checks)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM || true)

# ============================================================================
# 0. File Location Validation (runs first to catch organization issues)
# ============================================================================
if [ -n "$STAGED_FILES" ]; then
    FILE_LOCATION_ERRORS=0
    
    for file in $STAGED_FILES; do
        # Skip if file is deleted
        if [ ! -f "$file" ]; then
            continue
        fi
        
        # Check for markdown files in root (should be in docs/)
        if [[ "$file" =~ ^[^/]+\.md$ ]] && [[ "$file" != "README.md" ]] && [[ "$file" != "CHANGELOG.md" ]] && [[ "$file" != "LICENSE.md" ]]; then
            echo ":cross_mark: ERROR: Markdown file in root directory: $file" >&2
            echo "   Documentation files should be in docs/ structure" >&2
            echo "   See: docs/DOCUMENTATION_QUICK_REFERENCE.md" >&2
            FILE_LOCATION_ERRORS=$((FILE_LOCATION_ERRORS + 1))
        fi
        
        # Check for test files in root
        if [[ "$file" =~ ^test_.*\.py$ ]] && [[ ! "$file" =~ ^tests/ ]]; then
            echo ":cross_mark: ERROR: Test file in root directory: $file" >&2
            echo "   Test files should be in tests/ structure" >&2
            echo "   See: docs/concepts/TEST_ORGANIZATION.md" >&2
            FILE_LOCATION_ERRORS=$((FILE_LOCATION_ERRORS + 1))
        fi
    done
    
    if [ $FILE_LOCATION_ERRORS -gt 0 ]; then
        echo "" >&2
        echo "Please move files to correct locations before committing." >&2
        exit 1
    fi
fi

# ============================================================================
# 1. Prettier Formatting (runs first to format code before validation)
# ============================================================================
echo "Running Prettier on staged files..." >&2

# Check if prettier is available
if command -v npx >/dev/null 2>&1; then
  # Format frontend files if any are staged
  STAGED_FRONTEND_FILES=$(echo "$STAGED_FILES" | grep -E "^frontend/.*\.(js|jsx|ts|tsx|json|css|scss|less|html|md|graphql|vue|yaml|yml)$" || true)
  
  if [ -n "$STAGED_FRONTEND_FILES" ]; then
    cd frontend || exit 1
    if [ -f "package.json" ]; then
      # Format staged frontend files (strip frontend/ prefix for paths inside frontend/)
      # Use while loop to safely handle filenames with spaces
      echo "$STAGED_FRONTEND_FILES" | while IFS= read -r file; do
        [ -n "$file" ] && npx prettier --write "${file#frontend/}" 2>/dev/null || true
      done
      
      # Re-stage formatted files so changes are included in commit
      # Need to cd back to repo root for git add to work with full paths
      cd .. || exit 1
      echo "$STAGED_FRONTEND_FILES" | while IFS= read -r file; do
        [ -n "$file" ] && git add "$file" 2>/dev/null || true
      done
      cd frontend || exit 1
      
      # Check formatting (fail if files still need formatting)
      # Strip frontend/ prefix since we're inside frontend/ directory
      PRETTIER_CHECK_FAILED=false
      while IFS= read -r file; do
        if [ -n "$file" ] && ! npx prettier --check "${file#frontend/}" 2>/dev/null; then
          PRETTIER_CHECK_FAILED=true
        fi
      done < <(echo "$STAGED_FRONTEND_FILES")
      if [ "$PRETTIER_CHECK_FAILED" = "true" ]; then
        echo "" >&2
        echo ":cross_mark: Prettier formatting check failed for frontend files!" >&2
        echo "Please run: cd frontend && npx prettier --write 'src/**/*.{js,jsx,ts,tsx,json,css,scss,less,html,md,graphql,vue}'" >&2
        exit 1
      fi
    fi
    cd .. || exit 1
  fi
  
  # Format root-level and other files
  STAGED_ROOT_FILES=$(echo "$STAGED_FILES" | grep -E "\.(js|json|yaml|yml|md|html|css|scss|less)$" | grep -v "^frontend/" || true)
  
  if [ -n "$STAGED_ROOT_FILES" ]; then
    # Use while loop to safely handle filenames with spaces
    echo "$STAGED_ROOT_FILES" | while IFS= read -r file; do
      [ -n "$file" ] && npx prettier --write "$file" 2>/dev/null || true
    done
    
    # Re-stage formatted files so changes are included in commit
    echo "$STAGED_ROOT_FILES" | while IFS= read -r file; do
      [ -n "$file" ] && git add "$file" 2>/dev/null || true
    done
    
    # Check formatting (fail if files still need formatting)
    PRETTIER_CHECK_FAILED=false
    while IFS= read -r file; do
      if [ -n "$file" ] && ! npx prettier --check "$file" 2>/dev/null; then
        PRETTIER_CHECK_FAILED=true
      fi
    done < <(echo "$STAGED_ROOT_FILES")
    if [ "$PRETTIER_CHECK_FAILED" = "true" ]; then
      echo "" >&2
      echo ":cross_mark: Prettier formatting check failed for root files!" >&2
      echo "Please run: npx prettier --write '*.{js,json,yaml,yml,md}'" >&2
      exit 1
    fi
  fi
else
  echo "Warning: npx not found, skipping Prettier formatting" >&2
fi

# ============================================================================
# 2. Python Code Quality Checks (Black, isort, Pylint)
# ============================================================================
echo "Running Python code quality checks (Black, isort, Pylint)..." >&2

# Get staged Python files
STAGED_PYTHON_FILES=$(echo "$STAGED_FILES" | grep -E "\.py$" || true)

if [ -n "$STAGED_PYTHON_FILES" ]; then
    # Filter out excluded directories and problematic files
    FORMATTABLE_PYTHON_FILES=$(echo "$STAGED_PYTHON_FILES" | grep -vE "^(archive/|notebooks/|\.venv/|venv/|env/)" || true)
    
    # Filter out binary files, empty files, and files with merge conflicts
    if [ -n "$FORMATTABLE_PYTHON_FILES" ]; then
        FILTERED_FILES=""
        while IFS= read -r file; do
            # Skip if file doesn't exist (might be deleted)
            [ ! -f "$file" ] && continue
            
            # Skip empty files
            [ ! -s "$file" ] && continue
            
            # Skip binary files (check for null bytes or non-text content)
            if file "$file" 2>/dev/null | grep -qE "(binary|executable|compressed)" && ! file "$file" 2>/dev/null | grep -q "text"; then
                continue
            fi
            
            # Skip files with merge conflict markers
            if grep -qE "^<<<<<<< |^======= |^>>>>>>> " "$file" 2>/dev/null; then
                echo "Warning: Skipping $file (contains merge conflict markers)" >&2
                echo "  Resolve conflicts before committing." >&2
                continue
            fi
            
            # Skip very large files (>1MB) - formatting might be slow
            FILE_SIZE=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
            if [ "$FILE_SIZE" -gt 1048576 ]; then  # 1MB in bytes
                echo "Warning: Skipping $file (file size >1MB, formatting may be slow)" >&2
                continue
            fi
            
            FILTERED_FILES="$FILTERED_FILES $file"
        done <<< "$FORMATTABLE_PYTHON_FILES"
        FORMATTABLE_PYTHON_FILES=$(echo "$FILTERED_FILES" | xargs -n1 2>/dev/null || true)
    fi
    
    if [ -n "$FORMATTABLE_PYTHON_FILES" ]; then
        # Auto-format with isort FIRST (import sorting - must run before Black)
        ISORT_FAILED=false
        if command -v /opt/miniforge/envs/casa6/bin/isort >/dev/null 2>&1; then
            echo "Auto-sorting imports with isort..." >&2
            # Use while loop to safely handle filenames with spaces
            ISORT_TEMP_FAILED=false
            while IFS= read -r file; do
                if [ -n "$file" ] && ! /opt/miniforge/envs/casa6/bin/isort "$file" 2>/dev/null; then
                    ISORT_TEMP_FAILED=true
                fi
            done < <(echo "$FORMATTABLE_PYTHON_FILES")
            if [ "$ISORT_TEMP_FAILED" = "true" ]; then
                echo "Warning: isort encountered errors (continuing anyway)" >&2
                ISORT_FAILED=true
            fi
        else
            echo "Warning: isort not found in casa6 environment, skipping import sorting" >&2
            echo "  Install with: /opt/miniforge/envs/casa6/bin/pip install isort" >&2
        fi
        
        # Auto-format with Black SECOND (code formatting - runs after isort)
        BLACK_FAILED=false
        if command -v /opt/miniforge/envs/casa6/bin/black >/dev/null 2>&1; then
            echo "Auto-formatting Python files with Black..." >&2
            # Use while loop to safely handle filenames with spaces
            BLACK_TEMP_FAILED=false
            while IFS= read -r file; do
                if [ -n "$file" ] && ! /opt/miniforge/envs/casa6/bin/black "$file" 2>/dev/null; then
                    BLACK_TEMP_FAILED=true
                fi
            done < <(echo "$FORMATTABLE_PYTHON_FILES")
            if [ "$BLACK_TEMP_FAILED" = "true" ]; then
                echo "Warning: black encountered errors (continuing anyway)" >&2
                BLACK_FAILED=true
            fi
        else
            echo "Warning: black not found in casa6 environment, skipping formatting" >&2
            echo "  Install with: /opt/miniforge/envs/casa6/bin/pip install black" >&2
        fi
        
        # Only re-stage if formatting succeeded (at least partially)
        if [ "$ISORT_FAILED" = "false" ] || [ "$BLACK_FAILED" = "false" ]; then
            # Re-stage formatted files so changes are included in commit
            # Use while loop to safely handle filenames with spaces
            echo "$FORMATTABLE_PYTHON_FILES" | while IFS= read -r file; do
                [ -n "$file" ] && git add "$file" 2>/dev/null || true
            done
        fi
        
    fi
    
    # Then run Pylint for error checking
    if command -v /opt/miniforge/envs/casa6/bin/pre-commit >/dev/null 2>&1; then
        # Convert newlines to spaces for pre-commit --files argument
        STAGED_PYTHON_FILES_SPACE=$(echo "$STAGED_PYTHON_FILES" | tr '\n' ' ')
        # Only run Pylint (Black and isort already ran above, so skip them in pre-commit)
        if ! /opt/miniforge/envs/casa6/bin/pre-commit run pylint --files $STAGED_PYTHON_FILES_SPACE; then
            PYLINT_EXIT=$?
            echo "" >&2
            echo "ERROR: Pylint found errors!" >&2
            echo "Please fix the errors above before committing." >&2
            exit $PYLINT_EXIT
        fi
    else
        echo "Warning: pre-commit not found in casa6 environment, skipping Pylint checks" >&2
        echo "  Install with: /opt/miniforge/envs/casa6/bin/pip install pre-commit pylint" >&2
    fi
fi

# ============================================================================
# 3. Test Organization Validation
# ============================================================================
# Get list of staged test files
STAGED_TESTS=$(echo "$STAGED_FILES" | grep -E "tests/.*test_.*\.py$" || true)

if [ -z "$STAGED_TESTS" ]; then
    # No test files staged, skip validation
    exit 0
fi

echo "Validating test organization for staged files..." >&2

# Get repo root for portable paths
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

# Run validation script - capture exit code explicitly
# Note: Don't redirect here - let the script handle its own output
if ! /opt/miniforge/envs/casa6/bin/python "${REPO_ROOT}/scripts/validate-test-organization.py" --staged-only; then
    VALIDATION_EXIT=$?
    echo "" >&2
    echo "ERROR: Test organization validation failed!" >&2
    echo "Please fix the issues above before committing." >&2
    echo "" >&2
    echo "See docs/concepts/TEST_ORGANIZATION.md for test organization rules." >&2
    exit $VALIDATION_EXIT
fi

# Validation passed, allow commit
exit 0
