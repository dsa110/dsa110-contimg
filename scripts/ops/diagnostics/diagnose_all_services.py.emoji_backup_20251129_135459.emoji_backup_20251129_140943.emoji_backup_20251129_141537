#!/usr/bin/env python3
"""
Comprehensive service health diagnostics.

Tests all 51 API endpoints and services to identify:
- Exactly which services are degraded/unhealthy
- Root causes (missing endpoints, database issues, config problems)
- Actionable fixes for each issue
"""

import asyncio
import json
import socket
import sys
import time
import urllib.error
import urllib.request
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Color codes for terminal output
GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
BLUE = "\033[94m"
RESET = "\033[0m"
BOLD = "\033[1m"


class ServiceDiagnostic:
    """Test and diagnose individual service endpoints."""

    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.results = []

    def test_endpoint(
        self, name: str, path: str, expected_status: int = 200, timeout: int = 5
    ) -> Dict:
        """Test a single endpoint and return diagnostic info."""
        full_url = path if path.startswith("http") else f"{self.base_url}{path}"
        start_time = time.time()

        result = {
            "name": name,
            "endpoint": path,
            "status": "unknown",
            "http_code": None,
            "response_time_ms": None,
            "error": None,
            "details": None,
            "fix_suggestion": None,
        }

        try:
            req = urllib.request.Request(full_url)
            req.add_header("Accept", "application/json")

            with urllib.request.urlopen(req, timeout=timeout) as response:
                result["http_code"] = response.status
                result["response_time_ms"] = int((time.time() - start_time) * 1000)

                if response.status == expected_status:
                    result["status"] = "healthy"
                    result["details"] = (
                        f"HTTP {response.status} in {result['response_time_ms']}ms"
                    )
                else:
                    result["status"] = "degraded"
                    result["details"] = (
                        f"HTTP {response.status} (expected {expected_status})"
                    )
                    result["fix_suggestion"] = "Check endpoint implementation"

        except urllib.error.HTTPError as e:
            result["response_time_ms"] = int((time.time() - start_time) * 1000)
            result["http_code"] = e.code

            # Read error response
            try:
                error_body = e.read().decode("utf-8")
                error_data = json.loads(error_body)
                result["error"] = error_data.get("detail", str(e))
            except:
                result["error"] = str(e)

            # Classify based on HTTP code
            if e.code == 404:
                result["status"] = "degraded"
                result["details"] = "Endpoint not found (404)"
                result["fix_suggestion"] = (
                    "Implement missing route in backend/src/dsa110_contimg/api/routes.py"
                )
            elif e.code == 500:
                result["status"] = "degraded"
                result["details"] = "Internal server error (500)"
                result["fix_suggestion"] = "Check backend logs for exception details"
            elif e.code >= 400 and e.code < 500:
                result["status"] = "degraded"
                result["details"] = f"Client error ({e.code})"
                result["fix_suggestion"] = "Review request parameters or authentication"
            else:
                result["status"] = "unhealthy"
                result["details"] = f"HTTP {e.code}"
                result["fix_suggestion"] = "Investigate server configuration"

        except urllib.error.URLError as e:
            result["response_time_ms"] = int((time.time() - start_time) * 1000)
            result["status"] = "unhealthy"
            result["error"] = str(e.reason)
            result["details"] = "Connection failed"
            result["fix_suggestion"] = (
                "Check if backend service is running and accessible"
            )

        except socket.timeout:
            result["response_time_ms"] = int((time.time() - start_time) * 1000)
            result["status"] = "unhealthy"
            result["error"] = "Request timeout"
            result["details"] = f"Timeout after {timeout}s"
            result["fix_suggestion"] = (
                "Check for blocking operations or performance issues"
            )

        except Exception as e:
            result["response_time_ms"] = int((time.time() - start_time) * 1000)
            result["status"] = "unhealthy"
            result["error"] = str(e)
            result["details"] = f"Unexpected error: {type(e).__name__}"
            result["fix_suggestion"] = "Review error details and check service logs"

        return result

    def run_all_tests(self) -> List[Dict]:
        """Test all 51 services defined in SystemStatusPage.tsx."""

        tests = [
            # CORE BACKEND APIS (3)
            ("Backend API Health", "/api/health", 200),
            ("Health Summary", "/api/health/summary", 200),
            ("Health Services", "/api/health/services", 200),
            # PIPELINE APIS (6)
            ("Pipeline Status", "/api/status", 200),
            ("Pipeline Metrics Summary", "/api/pipeline/metrics/summary", 200),
            ("Pipeline Executions", "/api/pipeline/executions?limit=10", 200),
            ("Pipeline Active Executions", "/api/pipeline/executions/active", 200),
            ("Pipeline Dependency Graph", "/api/pipeline/dependency-graph", 200),
            ("Pipeline Stage Metrics", "/api/pipeline/stages/metrics?limit=10", 200),
            # JOB MANAGEMENT APIS (2)
            ("Jobs List", "/api/jobs?limit=10", 200),
            ("Batch Jobs List", "/api/batch?limit=10", 200),
            # DATA APIS (6)
            ("Measurement Sets", "/api/ms?limit=10", 200),
            ("Images", "/api/images?limit=10", 200),
            ("Data Instances", "/api/data?limit=10", 200),
            ("Mosaics", "/api/mosaics?limit=10", 200),
            ("Sources", "/api/sources?limit=10", 200),
            ("UVH5 Files", "/api/uvh5?limit=10", 200),
            # METRICS APIS (2)
            ("System Metrics", "/api/metrics/system", 200),
            ("Database Metrics", "/api/metrics/database", 200),
            # STREAMING APIS (4)
            ("Streaming Status", "/api/streaming/status", 200),
            ("Streaming Health", "/api/streaming/health", 200),
            ("Streaming Metrics", "/api/streaming/metrics", 200),
            ("Streaming Config", "/api/streaming/config", 200),
            # POINTING APIS (4)
            ("Pointing Monitor Status", "/api/pointing-monitor/status", 200),
            ("Pointing History", "/api/pointing/history?limit=10", 200),
            ("Pointing Sky Map Data", "/api/pointing/sky-map-data", 200),
            ("Pointing History Records", "/api/pointing_history?limit=10", 200),
            # OPERATIONS APIS (3)
            ("DLQ Stats", "/api/operations/dlq/stats", 200),
            ("DLQ Items", "/api/operations/dlq/items?limit=10", 200),
            ("Circuit Breakers", "/api/operations/circuit-breakers", 200),
            # EVENT & CACHE APIS (6)
            ("Event Statistics", "/api/events/stats", 200),
            ("Event Stream", "/api/events/stream?limit=10", 200),
            ("Event Types", "/api/events/types", 200),
            ("Cache Statistics", "/api/cache/stats", 200),
            ("Cache Keys", "/api/cache/keys?limit=10", 200),
            ("Cache Performance", "/api/cache/performance", 200),
            # CALIBRATION APIS (2)
            ("Calibration Status", "/api/calibration/status", 200),
            ("Cal Tables", "/api/caltables?limit=10", 200),
            # QA APIS (1)
            ("Alerts History", "/api/alerts/history?limit=10", 200),
            # VISUALIZATION APIS (4)
            ("Directory Listing", "/api/visualization/browse?path=/data", 200),
            ("FITS Info", "/api/visualization/fits/info?path=/data/test.fits", 200),
            (
                "Casa Table Info",
                "/api/visualization/casatable/info?path=/data/test.ms",
                200,
            ),
            ("CARTA Status", "/api/visualization/carta/status", 200),
            # CATALOG & REGIONS APIS (2)
            ("Catalog Overlay", "/api/catalog/overlay?ra=0&dec=0&radius=1", 200),
            ("Regions", "/api/regions?limit=10", 200),
            # ABSURD TASK MANAGEMENT (3)
            ("ABSURD Health", "/api/absurd/health", 200),
            ("ABSURD Tasks", "/api/absurd/tasks?limit=10", 200),
            ("ABSURD Queue Stats", "/api/absurd/queues/dsa110-pipeline/stats", 200),
            # WEBSOCKET (1)
            ("WebSocket Status", "/api/ws/status", 200),
            # REAL-TIME DATA (1)
            ("ESE Candidates", "/api/ese/candidates?limit=10", 200),
            # EXTERNAL SERVICES (1)
            ("CARTA Frontend", "http://localhost:9002", 200),
        ]

        print(f"{BOLD}Testing all 51 services...{RESET}\n")

        for name, path, expected in tests:
            result = self.test_endpoint(name, path, expected)
            self.results.append(result)

            # Print status
            status_color = (
                GREEN
                if result["status"] == "healthy"
                else YELLOW if result["status"] == "degraded" else RED
            )
            status_icon = (
                ":check_mark:"
                if result["status"] == "healthy"
                else ":warning_sign:" if result["status"] == "degraded" else ":ballot_x:"
            )
            print(
                f"{status_color}{status_icon}{RESET} {name:40s} {status_color}{result['status']:10s}{RESET} {result['details'] or ''}"
            )

        return self.results

    def generate_report(self) -> Dict:
        """Generate comprehensive diagnostic report."""
        healthy = [r for r in self.results if r["status"] == "healthy"]
        degraded = [r for r in self.results if r["status"] == "degraded"]
        unhealthy = [r for r in self.results if r["status"] == "unhealthy"]

        # Group issues by root cause
        missing_routes = [r for r in degraded + unhealthy if r["http_code"] == 404]
        server_errors = [r for r in degraded + unhealthy if r["http_code"] == 500]
        connection_failures = [r for r in unhealthy if r["http_code"] is None]

        report = {
            "timestamp": datetime.now().isoformat(),
            "summary": {
                "total": len(self.results),
                "healthy": len(healthy),
                "degraded": len(degraded),
                "unhealthy": len(unhealthy),
            },
            "issues": {
                "missing_routes": len(missing_routes),
                "server_errors": len(server_errors),
                "connection_failures": len(connection_failures),
            },
            "degraded_services": [
                {
                    "name": r["name"],
                    "endpoint": r["endpoint"],
                    "error": r["error"],
                    "fix": r["fix_suggestion"],
                }
                for r in degraded
            ],
            "unhealthy_services": [
                {
                    "name": r["name"],
                    "endpoint": r["endpoint"],
                    "error": r["error"],
                    "fix": r["fix_suggestion"],
                }
                for r in unhealthy
            ],
        }

        return report

    def print_summary(self):
        """Print summary and action plan."""
        report = self.generate_report()

        print(f"\n{'='*80}")
        print(f"{BOLD}DIAGNOSTIC SUMMARY{RESET}")
        print(f"{'='*80}\n")

        print(
            f"{GREEN}:check_mark: Healthy:{RESET}   {report['summary']['healthy']:2d} / {report['summary']['total']}"
        )
        print(
            f"{YELLOW}:warning_sign: Degraded:{RESET}  {report['summary']['degraded']:2d} / {report['summary']['total']}"
        )
        print(
            f"{RED}:ballot_x: Unhealthy:{RESET} {report['summary']['unhealthy']:2d} / {report['summary']['total']}"
        )

        print(f"\n{BOLD}ISSUE BREAKDOWN:{RESET}")
        print(f"  Missing routes (404):     {report['issues']['missing_routes']}")
        print(f"  Server errors (500):      {report['issues']['server_errors']}")
        print(f"  Connection failures:      {report['issues']['connection_failures']}")

        if report["degraded_services"]:
            print(f"\n{BOLD}{YELLOW}DEGRADED SERVICES:{RESET}")
            for svc in report["degraded_services"]:
                print(f"\n  {YELLOW}:warning_sign:{RESET} {BOLD}{svc['name']}{RESET}")
                print(f"    Endpoint: {svc['endpoint']}")
                print(f"    Error:    {svc['error']}")
                print(f"    Fix:      {BLUE}{svc['fix']}{RESET}")

        if report["unhealthy_services"]:
            print(f"\n{BOLD}{RED}UNHEALTHY SERVICES:{RESET}")
            for svc in report["unhealthy_services"]:
                print(f"\n  {RED}:ballot_x:{RESET} {BOLD}{svc['name']}{RESET}")
                print(f"    Endpoint: {svc['endpoint']}")
                print(f"    Error:    {svc['error']}")
                print(f"    Fix:      {BLUE}{svc['fix']}{RESET}")

        # Save detailed JSON report
        output_file = Path(
            "/data/dsa110-contimg/artifacts/logs/service_diagnostics.json"
        )
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, "w") as f:
            json.dump(report, f, indent=2)

        print(f"\n{BOLD}Detailed report saved to:{RESET} {output_file}")


def main():
    """Run comprehensive service diagnostics."""
    print(f"{BOLD}DSA-110 Service Health Diagnostics{RESET}")
    print(f"{'='*80}\n")

    diagnostic = ServiceDiagnostic()
    diagnostic.run_all_tests()
    diagnostic.print_summary()

    # Return exit code based on health
    report = diagnostic.generate_report()
    if report["summary"]["unhealthy"] > 0:
        return 2  # Critical issues
    elif report["summary"]["degraded"] > 0:
        return 1  # Non-critical issues
    return 0  # All healthy


if __name__ == "__main__":
    sys.exit(main())
