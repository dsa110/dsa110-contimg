#!/opt/miniforge/envs/casa6/bin/python
"""Comprehensive test of all dashboard endpoints with real and empty database scenarios."""

import sqlite3
import sys
from datetime import datetime, timedelta
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from dsa110_contimg.api.data_access import (fetch_alert_history,
                                            fetch_ese_candidates,
                                            fetch_mosaics,
                                            fetch_source_timeseries)


def test_with_database(db_path: Path, scenario_name: str):
    """Test all endpoints with a given database."""
    print(f"\n{'='*60}")
    print(f"Testing: {scenario_name}")
    print(f"Database: {db_path}")
    print(f"{'='*60}")
    
    if not db_path.exists():
        print(f"  Database does not exist - testing graceful degradation")
        db_path = Path("/nonexistent/database.sqlite3")
    
    results = {}
    
    # 1. ESE Candidates
    print("\n1. ESE Candidates Endpoint:")
    try:
        candidates = fetch_ese_candidates(db_path, limit=10, min_sigma=0)
        results['ese_candidates'] = {
            'status': 'PASS',
            'count': len(candidates),
            'works': True
        }
        print(f"   :check_mark: Returns {len(candidates)} candidates")
        if candidates:
            print(f"   :check_mark: First candidate: {candidates[0].get('source_id', 'N/A')}")
    except Exception as e:
        results['ese_candidates'] = {
            'status': 'FAIL',
            'error': str(e),
            'works': False
        }
        print(f"   :ballot_x: Error: {e}")
    
    # 2. Mosaics
    print("\n2. Mosaic Query Endpoint:")
    try:
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(days=7)
        mosaics = fetch_mosaics(db_path, start_time.isoformat(), end_time.isoformat())
        results['mosaics'] = {
            'status': 'PASS',
            'count': len(mosaics),
            'works': True
        }
        print(f"   :check_mark: Returns {len(mosaics)} mosaics")
        if mosaics:
            print(f"   :check_mark: First mosaic: {mosaics[0].get('name', 'N/A')}")
    except Exception as e:
        results['mosaics'] = {
            'status': 'FAIL',
            'error': str(e),
            'works': False
        }
        print(f"   :ballot_x: Error: {e}")
    
    # 3. Source Search
    print("\n3. Source Search Endpoint:")
    try:
        source = fetch_source_timeseries(db_path, "NVSS J123456+420312")
        results['source_search'] = {
            'status': 'PASS',
            'found': source is not None,
            'works': True
        }
        if source:
            print(f"   :check_mark: Found timeseries for source")
            print(f"   :check_mark: Flux points: {len(source.get('flux_points', []))}")
        else:
            print(f"   :check_mark: Returns None (graceful - no data)")
    except Exception as e:
        results['source_search'] = {
            'status': 'FAIL',
            'error': str(e),
            'works': False
        }
        print(f"   :ballot_x: Error: {e}")
    
    # 4. Alert History
    print("\n4. Alert History Endpoint:")
    try:
        alerts = fetch_alert_history(db_path, limit=10)
        results['alert_history'] = {
            'status': 'PASS',
            'count': len(alerts),
            'works': True
        }
        print(f"   :check_mark: Returns {len(alerts)} alerts")
        if alerts:
            print(f"   :check_mark: Most recent: {alerts[0].get('alert_type', 'N/A')}")
    except Exception as e:
        results['alert_history'] = {
            'status': 'FAIL',
            'error': str(e),
            'works': False
        }
        print(f"   :ballot_x: Error: {e}")
    
    return results


def main():
    """Run comprehensive endpoint tests."""
    print("Comprehensive Endpoint Testing")
    print("=" * 60)
    
    # Test with real database (products.sqlite3)
    db_real = Path("/data/dsa110-contimg/state/db/products.sqlite3")
    results_real = test_with_database(db_real, "Real Database (products.sqlite3)")
    
    # Test with empty/nonexistent database (graceful degradation)
    db_empty = Path("/tmp/test_empty_products.sqlite3")
    if db_empty.exists():
        db_empty.unlink()
    results_empty = test_with_database(db_empty, "Empty Database (graceful degradation)")
    
    # Summary
    print(f"\n{'='*60}")
    print("Test Summary")
    print(f"{'='*60}")
    
    endpoints = ['ese_candidates', 'mosaics', 'source_search', 'alert_history']
    
    print("\nReal Database (products.sqlite3):")
    for endpoint in endpoints:
        r = results_real.get(endpoint, {})
        status = ":check_mark: PASS" if r.get('works') else ":ballot_x: FAIL"
        count = r.get('count', 0) if 'count' in r else ('Found' if r.get('found') else 'None')
        print(f"  {endpoint:20s} {status:10s} ({count})")
    
    print("\nEmpty Database (graceful degradation):")
    for endpoint in endpoints:
        r = results_empty.get(endpoint, {})
        status = ":check_mark: PASS" if r.get('works') else ":ballot_x: FAIL"
        count = r.get('count', 0) if 'count' in r else ('None' if not r.get('found') else 'Found')
        print(f"  {endpoint:20s} {status:10s} ({count})")
    
    # Overall status
    all_pass_real = all(r.get('works', False) for r in results_real.values())
    all_pass_empty = all(r.get('works', False) for r in results_empty.values())
    
    print(f"\n{'='*60}")
    if all_pass_real and all_pass_empty:
        print(":check_mark: ALL ENDPOINTS WORKING CORRECTLY")
        print("  - Real database: All endpoints functional")
        print("  - Empty database: All endpoints handle gracefully")
    else:
        print(":ballot_x: SOME ENDPOINTS HAVE ISSUES")
        if not all_pass_real:
            print("  - Real database: Some endpoints failed")
        if not all_pass_empty:
            print("  - Empty database: Some endpoints failed")
    print(f"{'='*60}")
    
    return 0 if (all_pass_real and all_pass_empty) else 1


if __name__ == "__main__":
    sys.exit(main())

