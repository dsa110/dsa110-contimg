#!/opt/miniforge/envs/casa6/bin/python
"""
Find all available transits for a calibrator in the HDF5 database.

This script uses the pipeline's time-windowing functions to properly
identify complete observations containing the calibrator in the beam.
"""

import argparse
import sys
from pathlib import Path

from astropy.time import Time
from dsa110_contimg.calibration.catalogs import load_vla_catalog_from_sqlite
from dsa110_contimg.calibration.schedule import previous_transits
from dsa110_contimg.database.hdf5_index import query_subband_groups


def main():
    parser = argparse.ArgumentParser(
        description="Find all available transits for a calibrator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Find all 0834+555 transits
  %(prog)s 0834+555
  
  # Search last 30 days
  %(prog)s 0834+555 --days-back 30
  
  # Show incomplete groups too
  %(prog)s 0834+555 --show-incomplete
""",
    )
    parser.add_argument("calibrator", help="Calibrator name (e.g., 0834+555)")
    parser.add_argument(
        "--catalog",
        default="/data/dsa110-contimg/state/catalogs/vla_calibrators.sqlite3",
        help="Path to calibrator catalog (default: %(default)s)",
    )
    parser.add_argument(
        "--hdf5-db",
        default="/data/dsa110-contimg/state/hdf5.sqlite3",
        help="Path to HDF5 database (default: %(default)s)",
    )
    parser.add_argument(
        "--days-back",
        type=int,
        default=60,
        help="How many days back to search (default: 60)",
    )
    parser.add_argument(
        "--window-minutes",
        type=float,
        default=12.0,
        help="Search window around each transit in minutes (default: 12)",
    )
    parser.add_argument(
        "--show-incomplete",
        action="store_true",
        help="Show groups with <16 subbands",
    )

    args = parser.parse_args()

    # Load calibrator coordinates
    try:
        catalog = load_vla_catalog_from_sqlite(args.catalog)
        if args.calibrator not in catalog.index:
            print(f"Error: Calibrator {args.calibrator} not found in catalog")
            return 1
        source = catalog.loc[args.calibrator]
        ra_deg = float(source["ra_deg"])
        dec_deg = float(source["dec_deg"])
    except Exception as e:
        print(f"Error loading catalog: {e}")
        return 1

    print(f"Calibrator: {args.calibrator}")
    print(f"Coordinates: RA={ra_deg:.4f}°, Dec={dec_deg:.4f}°")
    print()

    # Calculate transit times
    print(f"Calculating transits for last {args.days_back} days...")
    transit_times = previous_transits(ra_deg, start_time=Time.now(), n=args.days_back)
    print(f"Found {len(transit_times)} calculated transit times")
    print()

    # Check each transit for available data
    available_transits = []
    half_window = args.window_minutes / 2

    for transit in transit_times:
        t0 = (transit - half_window * 60 / 86400.0).datetime.strftime(
            "%Y-%m-%d %H:%M:%S"
        )
        t1 = (transit + half_window * 60 / 86400.0).datetime.strftime(
            "%Y-%m-%d %H:%M:%S"
        )

        try:
            groups = query_subband_groups(
                Path(args.hdf5_db),
                t0,
                t1,
                cluster_tolerance_s=150.0,  # 2.5 min tolerance
            )

            # Find the group where transit falls within the observation time span
            best_group = None
            best_group_time = None

            for group in groups:
                if not (args.show_incomplete or group.present_count >= 16):
                    continue

                # Extract timestamp from first available file
                first_file = next((f for f in group.files if f is not None), None)
                if not first_file:
                    continue

                filename = Path(first_file).name
                group_time_str = filename.split("_sb")[0]

                # Parse the observation time
                try:
                    obs_time = Time(group_time_str, format="isot")
                    # DSA-110 observations are 4.9392 minutes (24 samples × 12.88s)
                    obs_start = obs_time
                    obs_end = obs_time + 4.9392 / (24 * 60)  # Duration in days

                    # Check if transit falls within observation span
                    if obs_start <= transit <= obs_end:
                        best_group = group
                        best_group_time = group_time_str
                        break  # Found the matching observation
                except Exception:
                    continue

            # Only add if we found a group containing the transit
            if best_group is not None:
                available_transits.append(
                    {
                        "transit": transit,
                        "group": best_group,
                        "group_time": best_group_time,
                        "date": transit.datetime.strftime("%Y-%m-%d"),
                    }
                )
        except Exception as e:
            print(f"Error querying transit {transit.iso}: {e}")

    # Display results
    if not available_transits:
        print(f"No data found for {args.calibrator} transits")
        return 0

    print(f"Found {len(available_transits)} observation(s) with data:")
    print()

    # Group by date
    by_date = {}
    for item in available_transits:
        date = item["date"]
        if date not in by_date:
            by_date[date] = []
        by_date[date].append(item)

    for date in sorted(by_date.keys()):
        items = by_date[date]
        print(f":calendar: {date}:")
        for item in items:
            group = item["group"]
            transit = item["transit"]
            complete = ":check_mark:" if group.present_count >= 16 else ":warning_sign:"
            transit_str = transit.datetime.strftime("%H:%M:%S")
            print(
                f"   {complete} Obs: {item['group_time']} | Transit: {transit_str} | "
                f"{group.present_count} subbands"
            )
        print()

    complete_count = sum(
        1 for item in available_transits if item["group"].present_count >= 16
    )
    print(f"Summary: {complete_count} complete / {len(available_transits)} total")

    return 0


if __name__ == "__main__":
    sys.exit(main())
