#!/bin/bash
# Universal Auto Error Detection Wrapper
# Wraps ALL commands (not just specific ones) with error detection
#
# Usage:
#   source scripts/auto-error-detection-universal.sh
#
# This version wraps every command, not just python/pytest/make

# Get script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Check if error detection wrapper exists
ERROR_DETECTION_WRAPPER="${ERROR_DETECTION_WRAPPER:-$PROJECT_ROOT/scripts/run-with-error-detection.py}"

if [ ! -f "$ERROR_DETECTION_WRAPPER" ]; then
    ERROR_DETECTION_WRAPPER="$PROJECT_ROOT/scripts/run-with-error-detection.sh"
fi

if [ ! -f "$ERROR_DETECTION_WRAPPER" ]; then
    echo "Warning: Error detection wrapper not found: $ERROR_DETECTION_WRAPPER" >&2
    echo "Auto error detection disabled." >&2
    return 1 2>/dev/null || exit 1
fi

# Make sure wrapper is executable
chmod +x "$ERROR_DETECTION_WRAPPER" 2>/dev/null || true

# Function to check if command should skip error detection
should_skip_command() {
    local cmd="$1"
    
    # Skip built-in shell commands
    local skip_commands=(
        "cd" "source" "." "export" "unset" "alias" "unalias"
        "set" "shopt" "type" "command" "which" "help" "man"
        "info" "history" "jobs" "fg" "bg" "exit" "logout"
        "clear" "reset" "echo" "printf" "test" "[" "true" "false"
        "read" "readonly" "declare" "local" "return" "function"
        "if" "then" "else" "elif" "fi" "case" "esac" "for" "while"
        "do" "done" "time" "exec" "eval"
    )
    
    for skip_cmd in "${skip_commands[@]}"; do
        if [ "$cmd" = "$skip_cmd" ]; then
            return 0  # Should skip
        fi
    done
    
    # Skip if it's a variable assignment
    if [[ "$cmd" =~ ^[a-zA-Z_][a-zA-Z0-9_]*= ]]; then
        return 0  # Should skip
    fi
    
    return 1  # Should not skip
}

# Function to wrap commands with error detection
_run_with_error_detection() {
    # Check if auto-detection is disabled for this command
    if [ -n "${SKIP_ERROR_DETECTION:-}" ]; then
        "$@"
        return $?
    fi
    
    # Check if command should skip
    if should_skip_command "$1"; then
        "$@"
        return $?
    fi
    
    # Run command with error detection
    "$ERROR_DETECTION_WRAPPER" "$@"
}

# Override command_not_found_handle to wrap unknown commands
# This catches commands that aren't functions or builtins
command_not_found_handle() {
    # Check if we should skip
    if [ -n "${SKIP_ERROR_DETECTION:-}" ] || should_skip_command "$1"; then
        # Try to run normally (will show "command not found" if it doesn't exist)
        command "$@" 2>&1
        return 127
    fi
    
    # Wrap with error detection
    _run_with_error_detection "$@"
}

# Export function for manual use
export -f _run_with_error_detection should_skip_command

# Set flag to indicate auto-detection is enabled
export AUTO_ERROR_DETECTION=1
export AUTO_ERROR_DETECTION_UNIVERSAL=1

echo ":white_heavy_check_mark: Universal auto error detection enabled"
echo "   ALL commands will be wrapped with error detection"
echo "   To disable: unset AUTO_ERROR_DETECTION"
echo "   To skip for one command: SKIP_ERROR_DETECTION=1 command args"

