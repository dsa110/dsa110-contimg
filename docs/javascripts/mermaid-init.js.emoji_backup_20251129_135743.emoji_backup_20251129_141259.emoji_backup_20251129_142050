// Render Mermaid diagrams - intercepts plugin's initialize() call
(function () {
  let originalInitialize = null;
  let initializeIntercepted = false;

  // Decode HTML entities and convert Unicode characters in Mermaid diagram text
  function sanitizeMermaidText(text) {
    if (!text) return text;

    // Create a temporary element to decode HTML entities
    const temp = document.createElement("textarea");
    temp.innerHTML = text;
    let decoded = temp.value;

    // Convert Unicode characters to ASCII equivalents for Mermaid compatibility
    const unicodeMap = {
      "→": "to",
      "≤": "<=",
      "≥": ">=",
      "≠": "!=",
      "≈": "~=",
      "±": "+/-",
    };

    for (const [unicode, ascii] of Object.entries(unicodeMap)) {
      decoded = decoded.replace(new RegExp(unicode, "g"), ascii);
    }

    return decoded;
  }

  // CRITICAL: Sanitize elements IMMEDIATELY when DOM is ready, BEFORE Mermaid processes them
  // This must run synchronously before any Mermaid initialization
  function sanitizeElementsImmediately() {
    const elements = document.querySelectorAll(".mermaid:not([data-sanitized])");
    if (elements.length === 0) return;

    console.log("[Mermaid Init] Immediate sanitization: processing", elements.length, "elements");

    elements.forEach((el) => {
      // CRITICAL: Get the raw HTML content BEFORE Mermaid processes it
      // pymdownx.superfences puts text directly in the div
      const rawHTML = el.innerHTML;

      // If innerHTML is empty or already processed by Mermaid, skip
      if (
        !rawHTML ||
        rawHTML.trim().length === 0 ||
        (rawHTML.includes("font-family") && rawHTML.includes("fill:"))
      ) {
        return;
      }

      // Extract the actual diagram text from HTML
      // The text might have HTML entities that need decoding
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = rawHTML;
      let originalText = tempDiv.textContent || tempDiv.innerText;

      // If that didn't work, try direct textContent
      if (!originalText || originalText.trim().length === 0) {
        originalText = el.textContent || el.innerText;
      }

      // If still empty, use innerHTML directly (it's plain text)
      if (!originalText || originalText.trim().length === 0) {
        originalText = rawHTML;
      }

      if (originalText && originalText.trim().length > 0) {
        const sanitized = sanitizeMermaidText(originalText);
        if (sanitized !== originalText) {
          console.log(
            "[Mermaid Init] Immediate sanitization: sanitized element, length:",
            originalText.length,
            "->",
            sanitized.length
          );
          // CRITICAL: Replace innerHTML, not just textContent
          // This ensures Mermaid sees the sanitized version
          el.innerHTML = sanitized;
          el.setAttribute("data-sanitized", "true");
        } else {
          el.setAttribute("data-sanitized", "true");
        }
      }
    });
  }

  // Run IMMEDIATELY - don't wait for anything
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", sanitizeElementsImmediately, { once: true });
  } else {
    // DOM already loaded, sanitize immediately
    sanitizeElementsImmediately();
  }

  // Also use MutationObserver to catch elements added dynamically
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === 1) {
          // Element node
          if (node.classList && node.classList.contains("mermaid")) {
            sanitizeElementsImmediately();
          }
          // Also check children
          const mermaidElements = node.querySelectorAll
            ? node.querySelectorAll(".mermaid:not([data-sanitized])")
            : [];
          if (mermaidElements.length > 0) {
            sanitizeElementsImmediately();
          }
        }
      });
    });
  });

  observer.observe(document.body || document.documentElement, {
    childList: true,
    subtree: true,
  });

  function renderDiagrams() {
    if (!window.mermaid) {
      console.log("[Mermaid Init] mermaid not available");
      return false;
    }
    if (typeof window.mermaid.run !== "function") {
      console.log(
        "[Mermaid Init] mermaid.run() not available, mermaid methods:",
        Object.keys(window.mermaid)
      );
      return false;
    }

    // Check all mermaid elements first
    const allElements = document.querySelectorAll(".mermaid");
    console.log("[Mermaid Init] Total mermaid elements:", allElements.length);

    const elements = document.querySelectorAll(".mermaid:not([data-processed])");
    console.log("[Mermaid Init] Found", elements.length, "unprocessed mermaid elements");

    // If no unprocessed elements but we have elements, try processing all of them
    const elementsToProcess = elements.length > 0 ? elements : allElements;

    if (elementsToProcess.length === 0) {
      console.log("[Mermaid Init] No mermaid elements found at all");
      return false;
    }

    console.log("[Mermaid Init] Processing", elementsToProcess.length, "elements");

    // Sanitize text content: decode HTML entities and convert Unicode characters
    elementsToProcess.forEach((el, idx) => {
      const originalText = el.textContent || el.innerText;
      if (originalText) {
        const sanitized = sanitizeMermaidText(originalText);
        if (sanitized !== originalText) {
          console.log(
            `[Mermaid Init] Sanitized element ${idx}: decoded HTML entities and/or converted Unicode`
          );
          el.textContent = sanitized;
        }
      }
    });

    // Use mermaid.run() API (v10+)
    console.log(
      "[Mermaid Init] Calling mermaid.run() with",
      elementsToProcess.length,
      "elements..."
    );

    // Comprehensive visual verification
    if (elementsToProcess.length > 0) {
      console.log("[Mermaid Init] === VISUAL VERIFICATION ===");
      let visibleCount = 0;
      let renderedCount = 0;
      let emptyCount = 0;

      elementsToProcess.forEach((el, idx) => {
        const svg = el.querySelector("svg");
        if (svg) {
          renderedCount++;
          // Check if SVG is actually visible
          const style = window.getComputedStyle(svg);
          const rect = svg.getBoundingClientRect();
          const hasContent = svg.querySelector("path, circle, rect, text, polygon") !== null;
          const isVisible =
            style.display !== "none" &&
            style.visibility !== "hidden" &&
            style.opacity !== "0" &&
            rect.width > 0 &&
            rect.height > 0;

          if (isVisible && hasContent) {
            visibleCount++;
          } else if (!hasContent) {
            emptyCount++;
          }

          if (idx === 0) {
            console.log("[Mermaid Init] Sample element (first):");
            console.log("  - SVG exists:", !!svg);
            console.log("  - SVG dimensions:", rect.width, "x", rect.height);
            console.log("  - Has drawing elements:", hasContent);
            console.log("  - Computed display:", style.display);
            console.log("  - Computed visibility:", style.visibility);
            console.log("  - Computed opacity:", style.opacity);
            console.log("  - Is visible:", isVisible);
            console.log("  - SVG innerHTML length:", svg.innerHTML.length);
          }
        }
      });

      console.log("[Mermaid Init] Summary:");
      console.log("  - Total elements:", elementsToProcess.length);
      console.log("  - Elements with SVG:", renderedCount);
      console.log("  - Visible & rendered:", visibleCount);
      console.log("  - Empty SVGs:", emptyCount);
      console.log(
        "  - Status:",
        visibleCount === elementsToProcess.length
          ? ":white_heavy_check_mark: ALL VISIBLE"
          : visibleCount > 0
            ? `:warning_sign::variation_selector-16:  PARTIAL: ${visibleCount}/${elementsToProcess.length}`
            : ":cross_mark: NONE VISIBLE"
      );
    }

    mermaid
      .run({
        nodes: Array.from(elementsToProcess),
      })
      .then((results) => {
        console.log("[Mermaid Init] mermaid.run() SUCCESS, results:", results);
        elementsToProcess.forEach((el) => el.setAttribute("data-processed", "true"));

        // Fix SVG dimensions - ensure they're visible
        elementsToProcess.forEach((el) => {
          const svg = el.querySelector("svg");
          if (svg) {
            // Check if SVG has dimensions
            const rect = svg.getBoundingClientRect();
            const hasViewBox = svg.hasAttribute("viewBox");
            const width = svg.getAttribute("width");
            const height = svg.getAttribute("height");
            const viewBox = svg.getAttribute("viewBox");

            // If SVG has no visible dimensions, fix it
            if (rect.width === 0 || rect.height === 0) {
              console.log(
                "[Mermaid Init] Fixing SVG dimensions (current:",
                rect.width,
                "x",
                rect.height,
                ")"
              );

              // Ensure container is visible and has proper display
              el.style.display = "block";
              el.style.minHeight = "200px";
              el.style.width = "100%";

              // If viewBox exists, use it to set proper dimensions
              if (hasViewBox && viewBox) {
                const vbParts = viewBox.split(/\s+/);
                if (vbParts.length >= 4) {
                  const vbWidth = parseFloat(vbParts[2]);
                  const vbHeight = parseFloat(vbParts[3]);
                  if (vbWidth > 0 && vbHeight > 0) {
                    // Set explicit width/height based on viewBox
                    if (!width || width === "100%") {
                      svg.setAttribute("width", vbWidth.toString());
                    }
                    if (!height || height === "100%") {
                      svg.setAttribute("height", vbHeight.toString());
                    }
                    console.log(
                      "[Mermaid Init] Set dimensions from viewBox:",
                      vbWidth,
                      "x",
                      vbHeight
                    );
                  }
                }
              }

              // Try to get dimensions from SVG content if still 0
              try {
                const bbox = svg.getBBox();
                if (bbox.width > 0 && bbox.height > 0) {
                  // If no viewBox, set it
                  if (!hasViewBox) {
                    svg.setAttribute("viewBox", `0 0 ${bbox.width} ${bbox.height}`);
                  }
                  // Set explicit width/height if still missing
                  if (!svg.getAttribute("width") || svg.getAttribute("width") === "100%") {
                    svg.setAttribute("width", bbox.width.toString());
                  }
                  if (!svg.getAttribute("height") || svg.getAttribute("height") === "100%") {
                    svg.setAttribute("height", bbox.height.toString());
                  }
                  console.log(
                    "[Mermaid Init] Set dimensions from getBBox():",
                    bbox.width,
                    "x",
                    bbox.height
                  );
                } else {
                  // Fallback: use CSS sizing
                  svg.style.width = "100%";
                  svg.style.height = "auto";
                  svg.style.maxWidth = "100%";
                  console.log("[Mermaid Init] Applied CSS fallback sizing");
                }
              } catch (e) {
                // getBBox() can fail if SVG is not rendered yet - use CSS fallback
                console.log("[Mermaid Init] getBBox() failed, using CSS fallback:", e.message);
                svg.style.width = "100%";
                svg.style.height = "auto";
                svg.style.maxWidth = "100%";
              }
            }
          }
        });

        // Re-check visibility after fix
        setTimeout(() => {
          let visibleAfterFix = 0;
          elementsToProcess.forEach((el) => {
            const svg = el.querySelector("svg");
            if (svg) {
              const rect = svg.getBoundingClientRect();
              if (rect.width > 0 && rect.height > 0) {
                visibleAfterFix++;
              }
            }
          });
          console.log(
            "[Mermaid Init] After dimension fix:",
            visibleAfterFix,
            "/",
            elementsToProcess.length,
            "visible"
          );
        }, 100);

        // Check for SVGs in multiple ways
        const svgs = document.querySelectorAll("svg.mermaid");
        const allSvgs = document.querySelectorAll("svg");
        console.log("[Mermaid Init] SVGs with class mermaid:", svgs.length);
        console.log("[Mermaid Init] Total SVGs on page:", allSvgs.length);

        // Check if SVGs are inside the mermaid divs
        elementsToProcess.forEach((el, idx) => {
          const svgInEl = el.querySelector("svg");
          console.log(`[Mermaid Init] Element ${idx} has SVG:`, !!svgInEl);
        });
      })
      .catch((err) => {
        console.error("[Mermaid Init] mermaid.run() ERROR:", err);
        console.error("[Mermaid Init] Error details:", err.message, err.stack);
        elementsToProcess.forEach((el) => el.setAttribute("data-processed", "error"));
      });

    return true;
  }

  // Sanitize all mermaid elements BEFORE Mermaid processes them
  function sanitizeAllMermaidElements() {
    const elements = document.querySelectorAll(".mermaid:not([data-sanitized])");
    if (elements.length === 0) return;

    console.log(
      "[Mermaid Init] Sanitizing",
      elements.length,
      "mermaid elements before Mermaid processes them"
    );

    elements.forEach((el, idx) => {
      // Get original text from innerHTML before Mermaid processes it
      // The text might be in a <code> tag or directly in the div
      let originalText = "";

      // Try to get text from code element first (pymdownx.superfences wraps it)
      const codeEl = el.querySelector("code");
      if (codeEl) {
        originalText = codeEl.textContent || codeEl.innerText;
      } else {
        // Otherwise get from the element itself
        originalText = el.textContent || el.innerText;
      }

      // If we still have CSS (Mermaid already processed), try to get from innerHTML
      if (originalText.includes("font-family") && originalText.includes("fill:")) {
        // Mermaid already processed - try to extract from HTML comments or data attributes
        const html = el.innerHTML;
        // Look for the original diagram text in HTML comments or data attributes
        const match = html.match(/<!--\s*(.*?)\s*-->/s) || html.match(/data-diagram="([^"]+)"/);
        if (match) {
          originalText = match[1];
        } else {
          // Last resort: try to find flowchart/graph keywords in innerHTML
          const diagramMatch = html.match(
            /(flowchart|graph|sequenceDiagram|classDiagram|stateDiagram|erDiagram|gantt|pie|gitgraph|journey|requirement|C4Context|C4Container|C4Component|C4Dynamic|C4Deployment)[\s\S]{0,5000}/
          );
          if (diagramMatch) {
            originalText = diagramMatch[0];
          }
        }
      }

      if (originalText && originalText.length > 0) {
        const sanitized = sanitizeMermaidText(originalText);
        if (sanitized !== originalText) {
          console.log(
            `[Mermaid Init] Pre-sanitized element ${idx}: decoded HTML entities and/or converted Unicode`
          );
          // Store sanitized text - replace the content
          if (codeEl) {
            codeEl.textContent = sanitized;
          } else {
            el.textContent = sanitized;
          }
          el.setAttribute("data-sanitized", "true");
        } else {
          el.setAttribute("data-sanitized", "true");
        }
      }
    });
  }

  // Intercept mermaid.initialize() BEFORE plugin calls it
  function interceptInitialize() {
    if (
      window.mermaid &&
      typeof window.mermaid.initialize === "function" &&
      !initializeIntercepted
    ) {
      initializeIntercepted = true;
      originalInitialize = window.mermaid.initialize.bind(window.mermaid);

      console.log("[Mermaid Init] Intercepted mermaid.initialize()");

      // Sanitize BEFORE Mermaid processes
      sanitizeAllMermaidElements();

      // Override initialize to render after plugin calls it
      window.mermaid.initialize = function (config) {
        console.log("[Mermaid Init] Plugin called initialize(), rendering diagrams...");

        // Sanitize again in case new elements were added
        sanitizeAllMermaidElements();

        // Call original initialize
        const result = originalInitialize(config);

        // Render diagrams after initialization
        setTimeout(() => {
          const rendered = renderDiagrams();
          console.log("[Mermaid Init] renderDiagrams() returned:", rendered);
        }, 50);

        return result;
      };
      return true;
    }
    return false;
  }

  // Check immediately and continuously until mermaid is available
  function setupInterception() {
    // Try immediately
    interceptInitialize();

    // Also check periodically (in case mermaid loads asynchronously)
    const checkInterval = setInterval(() => {
      if (interceptInitialize()) {
        clearInterval(checkInterval);
      }
    }, 50);

    // Stop after 3 seconds
    setTimeout(() => clearInterval(checkInterval), 3000);
  }

  // Sanitize immediately when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", sanitizeAllMermaidElements);
  } else {
    sanitizeAllMermaidElements();
  }

  // Start interception immediately
  setupInterception();

  // Also try on window load (fallback)
  window.addEventListener("load", () => {
    sanitizeAllMermaidElements();
    setTimeout(() => {
      if (!initializeIntercepted) {
        interceptInitialize();
      }
      if (window.mermaid && typeof window.mermaid.run === "function") {
        renderDiagrams();
      }
    }, 200);
  });

  // Handle Material theme dynamic content
  if (window.document$) {
    document$.subscribe(() => {
      setTimeout(() => {
        if (window.mermaid && typeof window.mermaid.run === "function") {
          renderDiagrams();
        }
      }, 200);
    });
  }
})();
