<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DSA-110 Continuum Pipeline Dashboard</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    h1 { font-size: 20px; }
    .cards { display: flex; gap: 12px; margin-bottom: 16px; }
    .card { border: 1px solid #ddd; padding: 10px; border-radius: 6px; min-width: 160px; }
    .label { color: #666; font-size: 12px; }
    .value { font-size: 20px; font-weight: 600; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; }
    th, td { border: 1px solid #ddd; padding: 6px; font-size: 14px; }
    th { background: #f4f4f4; text-align: left; }
    .muted { color: #777; font-style: italic; }
    .toolbar { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
    .spark { width: 140px; height: 24px; margin-top: 6px; }
  </style>
</head>
<body>
  <h1>DSA-110 Continuum Pipeline Dashboard</h1>
  <div class="cards" id="cards">
    <div class="card"><div class="label">Queue Total</div><div class="value" id="q_total">–</div></div>
    <div class="card"><div class="label">Pending</div><div class="value" id="q_pending">–</div></div>
    <div class="card"><div class="label">In Progress</div><div class="value" id="q_inprog">–</div></div>
    <div class="card"><div class="label">Completed</div><div class="value" id="q_done">–</div></div>
    <div class="card"><div class="label">Matched (recent)</div><div class="value" id="q_matched">–</div></div>
    <div class="card"><div class="label">CPU</div><div class="value" id="sys_cpu">–</div><div id="spark_cpu" class="spark"></div></div>
    <div class="card"><div class="label">Memory</div><div class="value" id="sys_mem">–</div><div id="spark_mem" class="spark"></div></div>
    <div class="card"><div class="label">Disk Used</div><div class="value" id="sys_disk">–</div><div id="spark_disk" class="spark"></div></div>
  </div>

  <div class="toolbar">
    <strong>Quicklooks</strong>
    <span class="muted">(latest)</span>
  </div>
  <div id="qa" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap:10px; margin-bottom: 16px;"></div>

  <div class="toolbar">
    <strong>Recent Groups</strong>
    <span class="muted">(links: <a href="/api/ui/calibrators">calibrator matches</a> · <a href="/ui/static/qa.html">quicklooks</a>)</span>
    <label style="margin-left:16px;">Matched only <input type="checkbox" id="matchedOnly"/></label>
    <label>Sort by
      <select id="sortBy">
        <option value="updated_desc" selected>Updated (newest)</option>
        <option value="updated_asc">Updated (oldest)</option>
        <option value="group_asc">Group (A→Z)</option>
      </select>
    </label>
  </div>
  <table>
    <thead>
      <tr><th>Thumb</th><th>Group</th><th>State</th><th>Subbands</th><th>Matched</th><th>Matches</th><th>Updated</th></tr>
    </thead>
    <tbody id="groups">
      <tr><td colspan="6" class="muted">Loading…</td></tr>
    </tbody>
  </table>

  <script>
  async function loadStatus() {
    const resp = await fetch('/api/status');
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.json();
  }

  async function loadSys() {
    const resp = await fetch('/api/metrics/system');
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.json();
  }

  async function loadQA(limit=12) {
    const resp = await fetch(`/api/qa?limit=${encodeURIComponent(limit)}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.json();
  }

  async function loadThumbs(limit=200) {
    const resp = await fetch(`/api/qa/thumbs?limit=${encodeURIComponent(limit)}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.json();
  }

  async function loadHistory(n=60) {
    const resp = await fetch(`/api/metrics/system/history?limit=${encodeURIComponent(n)}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.json();
  }

  function renderStatus(data, qaMap) {
    const q = data.queue || {};
    document.getElementById('q_total').textContent = q.total ?? '0';
    document.getElementById('q_pending').textContent = q.pending ?? '0';
    document.getElementById('q_inprog').textContent = q.in_progress ?? '0';
    document.getElementById('q_done').textContent = q.completed ?? '0';
    document.getElementById('q_matched').textContent = data.matched_recent ?? '0';

    const tbody = document.getElementById('groups');
    let items = data.recent_groups || [];
    const matchedOnly = document.getElementById('matchedOnly').checked;
    if (matchedOnly) items = items.filter(g => g.has_calibrator);
    const sort = document.getElementById('sortBy').value;
    items = items.slice();
    if (sort === 'updated_asc') items.sort((a,b)=> new Date(a.last_update)-new Date(b.last_update));
    else if (sort === 'group_asc') items.sort((a,b)=> (a.group_id||'').localeCompare(b.group_id||''));
    else items.sort((a,b)=> new Date(b.last_update)-new Date(a.last_update));
    if (!items.length) {
      tbody.innerHTML = '<tr><td colspan="7" class="muted">No recent groups</td></tr>';
      return;
    }
    tbody.innerHTML = items.map(g => {
      const last = formatRelative(g.last_update);
      const matches = (g.matches || []).map(m => `${m.name} (${m.sep_deg.toFixed(2)}°)`).join(', ');
      const thumb = qaMap[g.group_id] ? `<img src="${qaMap[g.group_id]}" style="width:64px;height:auto;border:1px solid #eee;"/>` : '<span class="muted">–</span>';
      return `<tr>
        <td>${thumb}</td>
        <td><a href="/ui/static/group.html?group=${encodeURIComponent(g.group_id)}">${g.group_id}</a></td>
        <td>${g.state}</td>
        <td>${g.subbands_present}/${g.expected_subbands}</td>
        <td>${g.has_calibrator ?? false}</td>
        <td>${matches || '<span class="muted">–</span>'}</td>
        <td title="${g.last_update}">${last}</td>
      </tr>`;
    }).join('');
  }

  function renderQA(data) {
    const grid = document.getElementById('qa');
    const items = (data && data.items) || [];
    if (!items.length) { grid.innerHTML = '<div class="muted">No quicklooks</div>'; return; }
    grid.innerHTML = items.map(it => {
      const url = `/api/qa/file/${encodeURIComponent(it.group_id)}/${encodeURIComponent(it.name)}`;
      const ts = it.created_at ? new Date(it.created_at).toLocaleString() : '';
      return `<div>
        <a href="/ui/static/group.html?group=${encodeURIComponent(it.group_id)}" title="${it.group_id} – ${ts}">
          <img src="${url}" alt="${it.name}" style="width:100%; height:auto; border:1px solid #eee;"/>
        </a>
      </div>`;
    }).join('');
  }

  function buildQaThumbMap(data) {
    const items = (data && data.items) || [];
    const map = {};
    for (const it of items) {
      if (!map[it.group_id]) {
        map[it.group_id] = `/api/qa/file/${encodeURIComponent(it.group_id)}/${encodeURIComponent(it.name)}`;
      }
    }
    return map;
  }

  function renderSys(sys) {
    const cpu = sys.cpu_percent != null ? `${sys.cpu_percent.toFixed(0)}%` : '–';
    const mem = sys.mem_percent != null ? `${sys.mem_percent.toFixed(0)}%` : '–';
    let disk = '–';
    if (sys.disk_total && sys.disk_used) {
      const pct = (sys.disk_used / sys.disk_total) * 100;
      disk = `${pct.toFixed(0)}%`;
    }
    document.getElementById('sys_cpu').textContent = cpu;
    document.getElementById('sys_mem').textContent = mem;
    document.getElementById('sys_disk').textContent = disk;
  }

  function formatRelative(iso) {
    try {
      const dt = new Date(iso);
      const now = new Date();
      const sec = Math.max(0, (now - dt) / 1000);
      if (sec < 60) return `${sec|0}s ago`;
      const min = sec/60; if (min < 60) return `${min|0}m ago`;
      const hr = min/60; if (hr < 48) return `${hr|0}h ago`;
      return dt.toLocaleString();
    } catch(e) { return iso; }
  }

  (async () => {
    try {
      const [status, qa, sys, thumbs, hist] = await Promise.all([loadStatus(), loadQA(200), loadSys(), loadThumbs(200), loadHistory(60)]);
      const qaMap = buildQaThumbMap(thumbs);
      renderStatus(status, qaMap);
      renderQA(qa);
      renderSys(sys);
      drawSpark('spark_cpu', hist, d => d.cpu_percent);
      drawSpark('spark_mem', hist, d => d.mem_percent);
      drawSpark('spark_disk', hist, d => (d.disk_used && d.disk_total) ? (d.disk_used/d.disk_total*100) : null);
      // Auto-refresh every 20 s
      setInterval(async () => {
        try {
          const [s2, q2, sys2, th2, hist2] = await Promise.all([loadStatus(), loadQA(200), loadSys(), loadThumbs(200), loadHistory(60)]);
          renderStatus(s2, buildQaThumbMap(th2));
          renderQA(q2);
          renderSys(sys2);
          drawSpark('spark_cpu', hist2, d => d.cpu_percent);
          drawSpark('spark_mem', hist2, d => d.mem_percent);
          drawSpark('spark_disk', hist2, d => (d.disk_used && d.disk_total) ? (d.disk_used/d.disk_total*100) : null);
        } catch(e) { /* ignore */ }
      }, 20000);
    } catch (e) {
      document.getElementById('groups').innerHTML = `<tr><td colspan="6" class="muted">Error: ${e.message}</td></tr>`;
    }
  })();
  </script>
</body>
</html>
  function drawSpark(elId, data, accessor) {
    const el = document.getElementById(elId);
    if (!el) return;
    const w = el.clientWidth || 120, h = 24; const pad=2;
    const pts = data.map((d,i)=>({x:i, y: accessor(d)})).filter(d=>d.y != null);
    if (pts.length === 0) { el.innerHTML=''; return; }
    const xmin=0, xmax=pts[pts.length-1].x;
    const ys = pts.map(p=>p.y);
    const ymin=Math.min(...ys), ymax=Math.max(...ys);
    const sx=x=> pad + (x-xmin)/(xmax-xmin||1) * (w-2*pad);
    const sy=y=> pad + (1- ( (y-(ymin||0)) / ((ymax-ymin)||1) )) * (h-2*pad);
    const d = pts.map((p,i)=> (i?'L':'M')+sx(p.x)+','+sy(p.y)).join(' ');
    el.innerHTML = `<svg width="${w}" height="${h}"><path d="${d}" fill="none" stroke="#3a7" stroke-width="1.5"/></svg>`;
  }
