{
    "bench_calibration.TimeApplyCal.time_applycal": {
        "code": "class TimeApplyCal:\n    def time_applycal(self):\n        \"\"\"Time applying calibration to all fields.\"\"\"\n        from casatasks import applycal\n    \n        applycal(\n            vis=str(self.work_ms),\n            field=\"\",  # All fields\n            gaintable=self.gaintables,\n            applymode=\"calflag\",\n        )\n\n    def setup(self):\n        \"\"\"Prepare test MS with calibration tables.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_apply_{self.test_ms.name}\"\n        self.caltable_dir = SCRATCH_DIR / \"caltables_apply\"\n    \n        if self.work_ms.exists():\n            shutil.rmtree(self.work_ms)\n        if self.caltable_dir.exists():\n            shutil.rmtree(self.caltable_dir)\n    \n        shutil.copytree(self.test_ms, self.work_ms)\n        self.caltable_dir.mkdir(exist_ok=True)\n    \n        # Create calibration tables\n        from dsa110_contimg.calibration.model import populate_model_from_catalog\n        try:\n            populate_model_from_catalog(str(self.work_ms), field=\"0\")\n        except Exception:\n            from casatasks import setjy\n            setjy(vis=str(self.work_ms), field=\"0\", standard=\"Perley-Butler 2017\")\n    \n        from dsa110_contimg.calibration.calibration import solve_bandpass, solve_gains\n    \n        self.refant = \"103,113,114,106,112\"\n        self.field = \"0\"\n    \n        self.bptables = solve_bandpass(\n            str(self.work_ms),\n            self.field,\n            self.refant,\n            None,\n            table_prefix=str(self.caltable_dir / \"setup\"),\n            minsnr=3.0,\n        )\n    \n        self.gtables = solve_gains(\n            str(self.work_ms),\n            self.field,\n            self.refant,\n            None,\n            self.bptables,\n            table_prefix=str(self.caltable_dir / \"setup\"),\n            minsnr=3.0,\n        )\n    \n        self.gaintables = self.bptables + self.gtables",
        "min_run_count": 2,
        "name": "bench_calibration.TimeApplyCal.time_applycal",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 300,
        "type": "time",
        "unit": "seconds",
        "version": "ebb2dafd8560773c26a01eebbb322573596cf7f221a6cffde7a05ff93d0b612a",
        "warmup_time": -1
    },
    "bench_calibration.TimeBandpassSolve.time_solve_bandpass": {
        "code": "class TimeBandpassSolve:\n    def time_solve_bandpass(self):\n        \"\"\"Time bandpass solve using pipeline function.\"\"\"\n        from dsa110_contimg.calibration.calibration import solve_bandpass\n    \n        solve_bandpass(\n            str(self.work_ms),\n            self.field,\n            self.refant,\n            None,  # No K-table\n            table_prefix=str(self.caltable_dir / \"bench\"),\n            combine_fields=False,\n            combine_spw=False,\n            minsnr=3.0,\n        )\n\n    def setup(self):\n        \"\"\"Prepare test MS and working directory.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        # Create scratch working copy to avoid modifying original\n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_bp_{self.test_ms.name}\"\n        self.caltable_dir = SCRATCH_DIR / \"caltables_bp\"\n    \n        if self.work_ms.exists():\n            shutil.rmtree(self.work_ms)\n        if self.caltable_dir.exists():\n            shutil.rmtree(self.caltable_dir)\n    \n        shutil.copytree(self.test_ms, self.work_ms)\n        self.caltable_dir.mkdir(exist_ok=True)\n    \n        # Pre-populate MODEL_DATA (required precondition)\n        from dsa110_contimg.calibration.model import populate_model_from_catalog\n        try:\n            populate_model_from_catalog(str(self.work_ms), field=\"0\")\n        except Exception:\n            # Fallback to setjy\n            from casatasks import setjy\n            setjy(vis=str(self.work_ms), field=\"0\", standard=\"Perley-Butler 2017\")\n    \n        self.refant = \"103,113,114,106,112\"\n        self.field = \"0\"",
        "min_run_count": 2,
        "name": "bench_calibration.TimeBandpassSolve.time_solve_bandpass",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 300,
        "type": "time",
        "unit": "seconds",
        "version": "8cebb1a10e590167f7b14ce430f0a42727c1126e890c53828adbb51f31243129",
        "warmup_time": -1
    },
    "bench_calibration.TimeCalibrationImport.time_import_calibration_module": {
        "code": "class TimeCalibrationImport:\n    def time_import_calibration_module(self):\n        \"\"\"Time importing the calibration module.\"\"\"\n        import importlib\n        import sys\n    \n        # Force reimport\n        mods_to_remove = [k for k in sys.modules if k.startswith(\"dsa110_contimg.calibration\")]\n        for mod in mods_to_remove:\n            del sys.modules[mod]\n    \n        import dsa110_contimg.calibration.calibration  # noqa: F401",
        "min_run_count": 2,
        "name": "bench_calibration.TimeCalibrationImport.time_import_calibration_module",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60,
        "type": "time",
        "unit": "seconds",
        "version": "21cd5ad42226050d07a4d6299cfad123f9b6e5c35438e920cbcc6bdafaa31719",
        "warmup_time": -1
    },
    "bench_calibration.TimeCalibrationImport.time_import_casa_tasks": {
        "code": "class TimeCalibrationImport:\n    def time_import_casa_tasks(self):\n        \"\"\"Time importing casatasks.\"\"\"\n        import importlib\n        import sys\n    \n        mods_to_remove = [k for k in sys.modules if k.startswith(\"casatasks\")]\n        for mod in mods_to_remove:\n            del sys.modules[mod]\n    \n        from casatasks import bandpass, gaincal, applycal  # noqa: F401",
        "min_run_count": 2,
        "name": "bench_calibration.TimeCalibrationImport.time_import_casa_tasks",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60,
        "type": "time",
        "unit": "seconds",
        "version": "69b2c354e2c118cb39510fcb5e65f24dfa9b020be70489e75ad88f57f34d6f97",
        "warmup_time": -1
    },
    "bench_calibration.TimeGainSolve.time_solve_gains": {
        "code": "class TimeGainSolve:\n    def time_solve_gains(self):\n        \"\"\"Time gain solve using pipeline function.\"\"\"\n        from dsa110_contimg.calibration.calibration import solve_gains\n    \n        solve_gains(\n            str(self.work_ms),\n            self.field,\n            self.refant,\n            None,  # No K-table\n            self.bptables,\n            table_prefix=str(self.caltable_dir / \"bench\"),\n            combine_fields=False,\n            minsnr=3.0,\n        )\n\n    def setup(self):\n        \"\"\"Prepare test MS with bandpass tables.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_gain_{self.test_ms.name}\"\n        self.caltable_dir = SCRATCH_DIR / \"caltables_gain\"\n    \n        if self.work_ms.exists():\n            shutil.rmtree(self.work_ms)\n        if self.caltable_dir.exists():\n            shutil.rmtree(self.caltable_dir)\n    \n        shutil.copytree(self.test_ms, self.work_ms)\n        self.caltable_dir.mkdir(exist_ok=True)\n    \n        # Pre-populate MODEL_DATA\n        from dsa110_contimg.calibration.model import populate_model_from_catalog\n        try:\n            populate_model_from_catalog(str(self.work_ms), field=\"0\")\n        except Exception:\n            from casatasks import setjy\n            setjy(vis=str(self.work_ms), field=\"0\", standard=\"Perley-Butler 2017\")\n    \n        # Create bandpass table first (required for gain solve)\n        from dsa110_contimg.calibration.calibration import solve_bandpass\n    \n        self.refant = \"103,113,114,106,112\"\n        self.field = \"0\"\n    \n        self.bptables = solve_bandpass(\n            str(self.work_ms),\n            self.field,\n            self.refant,\n            None,\n            table_prefix=str(self.caltable_dir / \"setup\"),\n            minsnr=3.0,\n        )",
        "min_run_count": 2,
        "name": "bench_calibration.TimeGainSolve.time_solve_gains",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 300,
        "type": "time",
        "unit": "seconds",
        "version": "73cf83b1f225c5b80e23c7a7f084d557146a1542ea5dccc327d6872e51743149",
        "warmup_time": -1
    },
    "bench_calibration.TimeModelPopulation.time_populate_model_from_catalog": {
        "code": "class TimeModelPopulation:\n    def time_populate_model_from_catalog(self):\n        \"\"\"Time MODEL_DATA population from catalog.\"\"\"\n        from dsa110_contimg.calibration.model import populate_model_from_catalog\n    \n        populate_model_from_catalog(str(self.work_ms), field=\"0\")\n\n    def setup(self):\n        \"\"\"Prepare test MS.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_model_{self.test_ms.name}\"\n    \n        if self.work_ms.exists():\n            shutil.rmtree(self.work_ms)\n    \n        shutil.copytree(self.test_ms, self.work_ms)",
        "min_run_count": 2,
        "name": "bench_calibration.TimeModelPopulation.time_populate_model_from_catalog",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 120,
        "type": "time",
        "unit": "seconds",
        "version": "a89de570a6f60dc9698685a637cb8aa66ff658c00642899bdd617d06dd203c03",
        "warmup_time": -1
    },
    "bench_conversion.TimeDirectMSWriter.time_direct_ms_write": {
        "code": "class TimeDirectMSWriter:\n    def time_direct_ms_write(self):\n        \"\"\"Time direct MS writing using pipeline writer.\"\"\"\n        from dsa110_contimg.conversion.strategies.writers import get_writer\n    \n        writer_cls = get_writer(\"parallel-subband\")\n        writer = writer_cls(\n            self.uvd,\n            str(self.output_ms),\n            file_list=[str(f) for f in self.hdf5_files[:4]],\n        )\n        writer.write()\n\n    def setup(self):\n        \"\"\"Prepare test data and output directory.\"\"\"\n        self.hdf5_files = _find_subband_group()\n        if self.hdf5_files is None:\n            raise NotImplementedError(\"No HDF5 files available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.output_dir = SCRATCH_DIR / \"bench_conversion\"\n    \n        if self.output_dir.exists():\n            shutil.rmtree(self.output_dir)\n        self.output_dir.mkdir()\n    \n        # Load first subband for writer test\n        from pyuvdata import UVData\n        self.uvd = UVData()\n        self.uvd.read(str(self.hdf5_files[0]), file_type=\"uvh5\")\n    \n        self.output_ms = self.output_dir / \"bench_output.ms\"",
        "min_run_count": 2,
        "name": "bench_conversion.TimeDirectMSWriter.time_direct_ms_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 300,
        "type": "time",
        "unit": "seconds",
        "version": "bbcdec8866a79f48b0bb02a1254130c18dea52a897bcd5439c6e4923efac316d",
        "warmup_time": -1
    },
    "bench_conversion.TimeFullConversion.time_convert_subband_group": {
        "code": "class TimeFullConversion:\n    def time_convert_subband_group(self):\n        \"\"\"Time full subband group conversion.\"\"\"\n        from dsa110_contimg.conversion.strategies.hdf5_orchestrator import (\n            convert_single_group,\n        )\n    \n        convert_single_group(\n            [str(f) for f in self.hdf5_files],\n            str(self.output_dir),\n        )\n\n    def setup(self):\n        \"\"\"Prepare test data.\"\"\"\n        self.hdf5_files = _find_subband_group()\n        if self.hdf5_files is None:\n            raise NotImplementedError(\"No HDF5 files available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.output_dir = SCRATCH_DIR / \"bench_full_conversion\"\n    \n        if self.output_dir.exists():\n            shutil.rmtree(self.output_dir)\n        self.output_dir.mkdir()\n    \n        # Get timestamp from first file\n        name = self.hdf5_files[0].name\n        self.timestamp = name.split(\"_sb\")[0]",
        "min_run_count": 2,
        "name": "bench_conversion.TimeFullConversion.time_convert_subband_group",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 600,
        "type": "time",
        "unit": "seconds",
        "version": "8409d7544104830d737e23b7202fb251119dbabacc1c865aac31c915797f141f",
        "warmup_time": -1
    },
    "bench_conversion.TimeUVDataLoad.time_load_four_subbands": {
        "code": "class TimeUVDataLoad:\n    def time_load_four_subbands(self):\n        \"\"\"Time loading 4 subbands and combining.\"\"\"\n        from pyuvdata import UVData\n    \n        uvd = UVData()\n        for i, f in enumerate(self.hdf5_files[:4]):\n            if i == 0:\n                uvd.read(str(f), file_type=\"uvh5\")\n            else:\n                uvd2 = UVData()\n                uvd2.read(str(f), file_type=\"uvh5\")\n                uvd += uvd2\n\n    def setup(self):\n        \"\"\"Find test HDF5 files.\"\"\"\n        self.hdf5_files = _find_subband_group()\n        if self.hdf5_files is None:\n            raise NotImplementedError(\"No HDF5 files available\")\n    \n        # Use just one file for single-file benchmark\n        self.single_file = self.hdf5_files[0]",
        "min_run_count": 2,
        "name": "bench_conversion.TimeUVDataLoad.time_load_four_subbands",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 120,
        "type": "time",
        "unit": "seconds",
        "version": "0c8ad4432e5ed05ebc566e4f72d9f41204d125a2a46731967e854dda6656b166",
        "warmup_time": -1
    },
    "bench_conversion.TimeUVDataLoad.time_load_single_subband": {
        "code": "class TimeUVDataLoad:\n    def time_load_single_subband(self):\n        \"\"\"Time loading a single subband HDF5 file.\"\"\"\n        from pyuvdata import UVData\n    \n        uvd = UVData()\n        uvd.read(str(self.single_file), file_type=\"uvh5\")\n\n    def setup(self):\n        \"\"\"Find test HDF5 files.\"\"\"\n        self.hdf5_files = _find_subband_group()\n        if self.hdf5_files is None:\n            raise NotImplementedError(\"No HDF5 files available\")\n    \n        # Use just one file for single-file benchmark\n        self.single_file = self.hdf5_files[0]",
        "min_run_count": 2,
        "name": "bench_conversion.TimeUVDataLoad.time_load_single_subband",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 120,
        "type": "time",
        "unit": "seconds",
        "version": "8ba2756b1771929289dabbe82a081955c0d7754f0326995d7aa79acf3ceee4cf",
        "warmup_time": -1
    },
    "bench_flagging.TimeFlagPipeline.time_full_flagging_pipeline": {
        "code": "class TimeFlagPipeline:\n    def time_full_flagging_pipeline(self):\n        \"\"\"Time complete flagging pipeline.\"\"\"\n        from dsa110_contimg.calibration.flagging import (\n            flag_rfi,\n            flag_zeros,\n            reset_flags,\n        )\n    \n        reset_flags(str(self.work_ms))\n        flag_zeros(str(self.work_ms))\n        flag_rfi(str(self.work_ms))\n\n    def setup(self):\n        \"\"\"Prepare test MS.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_flagpipe_{self.test_ms.name}\"\n    \n        if self.work_ms.exists():\n            shutil.rmtree(self.work_ms)\n    \n        shutil.copytree(self.test_ms, self.work_ms)",
        "min_run_count": 2,
        "name": "bench_flagging.TimeFlagPipeline.time_full_flagging_pipeline",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 600,
        "type": "time",
        "unit": "seconds",
        "version": "63592d486f8533941bfede113861b6695bd6f526636bf9eacfe5135abd5419c0",
        "warmup_time": -1
    },
    "bench_flagging.TimeFlagRFI.time_flag_rfi": {
        "code": "class TimeFlagRFI:\n    def time_flag_rfi(self):\n        \"\"\"Time AOFlagger RFI flagging using pipeline function.\"\"\"\n        from dsa110_contimg.calibration.flagging import flag_rfi\n    \n        flag_rfi(str(self.work_ms))\n\n    def setup(self):\n        \"\"\"Prepare test MS.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_rfi_{self.test_ms.name}\"\n    \n        if self.work_ms.exists():\n            shutil.rmtree(self.work_ms)\n    \n        shutil.copytree(self.test_ms, self.work_ms)\n    \n        # Reset flags first\n        from dsa110_contimg.calibration.flagging import reset_flags\n        reset_flags(str(self.work_ms))",
        "min_run_count": 2,
        "name": "bench_flagging.TimeFlagRFI.time_flag_rfi",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 600,
        "type": "time",
        "unit": "seconds",
        "version": "07032c858980de3b81b54fe8b36cc1ae6b29006302ccc43bee5a6f79cdc6c02d",
        "warmup_time": -1
    },
    "bench_flagging.TimeFlagReset.time_reset_flags": {
        "code": "class TimeFlagReset:\n    def time_reset_flags(self):\n        \"\"\"Time flag reset using pipeline function.\"\"\"\n        from dsa110_contimg.calibration.flagging import reset_flags\n    \n        reset_flags(str(self.work_ms))\n\n    def setup(self):\n        \"\"\"Prepare test MS.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_reset_{self.test_ms.name}\"\n    \n        if self.work_ms.exists():\n            shutil.rmtree(self.work_ms)\n    \n        shutil.copytree(self.test_ms, self.work_ms)",
        "min_run_count": 2,
        "name": "bench_flagging.TimeFlagReset.time_reset_flags",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60,
        "type": "time",
        "unit": "seconds",
        "version": "4372087a6f208c0a9a55986116ca6a130864a96be479faab836b747f6e8267d4",
        "warmup_time": -1
    },
    "bench_flagging.TimeFlagZeros.time_flag_zeros": {
        "code": "class TimeFlagZeros:\n    def time_flag_zeros(self):\n        \"\"\"Time zero flagging using pipeline function.\"\"\"\n        from dsa110_contimg.calibration.flagging import flag_zeros\n    \n        flag_zeros(str(self.work_ms))\n\n    def setup(self):\n        \"\"\"Prepare test MS.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_zeros_{self.test_ms.name}\"\n    \n        if self.work_ms.exists():\n            shutil.rmtree(self.work_ms)\n    \n        shutil.copytree(self.test_ms, self.work_ms)\n    \n        # Reset flags first for consistent baseline\n        from dsa110_contimg.calibration.flagging import reset_flags\n        reset_flags(str(self.work_ms))",
        "min_run_count": 2,
        "name": "bench_flagging.TimeFlagZeros.time_flag_zeros",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 120,
        "type": "time",
        "unit": "seconds",
        "version": "3246652e3b3616c5ee224bf989458465f21876536d826b9defe0de2bce1ef620",
        "warmup_time": -1
    },
    "bench_imaging.TimeImagingPipeline.time_pipeline_imaging": {
        "code": "class TimeImagingPipeline:\n    def time_pipeline_imaging(self):\n        \"\"\"Time imaging through pipeline wrapper.\"\"\"\n        from dsa110_contimg.imaging.wsclean import run_wsclean\n    \n        run_wsclean(\n            ms_path=str(self.test_ms),\n            imagename=self.imagename,\n            imsize=512,\n            niter=500,\n            threshold=\"0.5mJy\",\n        )\n\n    def setup(self):\n        \"\"\"Prepare test MS and output directory.\"\"\"\n        self.test_ms = _find_calibrated_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.output_dir = SCRATCH_DIR / \"bench_imaging_pipe\"\n    \n        if self.output_dir.exists():\n            shutil.rmtree(self.output_dir)\n        self.output_dir.mkdir()\n    \n        self.imagename = str(self.output_dir / \"pipeline\")",
        "min_run_count": 2,
        "name": "bench_imaging.TimeImagingPipeline.time_pipeline_imaging",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 600,
        "type": "time",
        "unit": "seconds",
        "version": "4c4174e1927b92f02035b4f83ed825dfd11a5c5283fcde1ebdb316212c4e0556",
        "warmup_time": -1
    },
    "bench_imaging.TimeWSCleanClean.time_wsclean_clean_500iter": {
        "code": "class TimeWSCleanClean:\n    def time_wsclean_clean_500iter(self):\n        \"\"\"Time WSClean with 500 iterations.\"\"\"\n        import subprocess\n    \n        cmd = [\n            \"wsclean\",\n            \"-size\", \"512\", \"512\",\n            \"-scale\", \"4asec\",\n            \"-niter\", \"500\",\n            \"-threshold\", \"0.5mJy\",\n            \"-pol\", \"I\",\n            \"-weight\", \"briggs\", \"0\",\n            \"-name\", self.imagename,\n            \"-data-column\", \"CORRECTED_DATA\",\n            str(self.test_ms),\n        ]\n    \n        subprocess.run(cmd, check=True, capture_output=True)\n\n    def setup(self):\n        \"\"\"Prepare test MS and output directory.\"\"\"\n        self.test_ms = _find_calibrated_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.output_dir = SCRATCH_DIR / \"bench_wsclean_clean\"\n    \n        if self.output_dir.exists():\n            shutil.rmtree(self.output_dir)\n        self.output_dir.mkdir()\n    \n        self.imagename = str(self.output_dir / \"clean\")",
        "min_run_count": 2,
        "name": "bench_imaging.TimeWSCleanClean.time_wsclean_clean_500iter",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 600,
        "type": "time",
        "unit": "seconds",
        "version": "46b8103ad64ce88dfcfdc722a5d7babcbc6e56ce43303dc2add07a57d2969ee7",
        "warmup_time": -1
    },
    "bench_imaging.TimeWSCleanDirty.time_wsclean_dirty": {
        "code": "class TimeWSCleanDirty:\n    def time_wsclean_dirty(self):\n        \"\"\"Time WSClean dirty imaging.\"\"\"\n        import subprocess\n    \n        cmd = [\n            \"wsclean\",\n            \"-size\", \"512\", \"512\",\n            \"-scale\", \"4asec\",\n            \"-niter\", \"0\",\n            \"-pol\", \"I\",\n            \"-weight\", \"briggs\", \"0\",\n            \"-name\", self.imagename,\n            \"-data-column\", \"CORRECTED_DATA\",\n            str(self.test_ms),\n        ]\n    \n        subprocess.run(cmd, check=True, capture_output=True)\n\n    def setup(self):\n        \"\"\"Prepare test MS and output directory.\"\"\"\n        self.test_ms = _find_calibrated_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.output_dir = SCRATCH_DIR / \"bench_wsclean_dirty\"\n    \n        if self.output_dir.exists():\n            shutil.rmtree(self.output_dir)\n        self.output_dir.mkdir()\n    \n        self.imagename = str(self.output_dir / \"dirty\")",
        "min_run_count": 2,
        "name": "bench_imaging.TimeWSCleanDirty.time_wsclean_dirty",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 300,
        "type": "time",
        "unit": "seconds",
        "version": "f4bc9a70e0e90e9675045660742532c2baa651b71d7dca942515a1a062d93ac0",
        "warmup_time": -1
    },
    "bench_imaging.TimeWSCleanWithIDG.time_wsclean_idg": {
        "code": "class TimeWSCleanWithIDG:\n    def time_wsclean_idg(self):\n        \"\"\"Time WSClean with IDG gridder.\"\"\"\n        import subprocess\n    \n        cmd = [\n            \"wsclean\",\n            \"-size\", \"512\", \"512\",\n            \"-scale\", \"4asec\",\n            \"-niter\", \"500\",\n            \"-threshold\", \"0.5mJy\",\n            \"-pol\", \"I\",\n            \"-weight\", \"briggs\", \"0\",\n            \"-use-idg\",\n            \"-idg-mode\", \"hybrid\",\n            \"-name\", self.imagename,\n            \"-data-column\", \"CORRECTED_DATA\",\n            str(self.test_ms),\n        ]\n    \n        subprocess.run(cmd, check=True, capture_output=True)\n\n    def setup(self):\n        \"\"\"Prepare test MS and output directory.\"\"\"\n        self.test_ms = _find_calibrated_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        # Check if IDG is available\n        import subprocess\n        result = subprocess.run(\n            [\"wsclean\", \"--version\"],\n            capture_output=True,\n            text=True,\n        )\n        if \"idg\" not in result.stdout.lower():\n            raise NotImplementedError(\"WSClean not built with IDG support\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.output_dir = SCRATCH_DIR / \"bench_wsclean_idg\"\n    \n        if self.output_dir.exists():\n            shutil.rmtree(self.output_dir)\n        self.output_dir.mkdir()\n    \n        self.imagename = str(self.output_dir / \"idg\")",
        "min_run_count": 2,
        "name": "bench_imaging.TimeWSCleanWithIDG.time_wsclean_idg",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 600,
        "type": "time",
        "unit": "seconds",
        "version": "8c27d0a27977bc6346c1666f6f73dffc411fb2e57f4055ee6a07d828da0fc92d",
        "warmup_time": -1
    },
    "version": 2
}