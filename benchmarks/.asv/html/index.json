{"project": "dsa110-contimg", "project_url": "https://github.com/dsa110/dsa110-contimg", "show_commit_url": "https://github.com/dsa110/dsa110-contimg/commit/", "hash_length": 8, "revision_to_hash": {"462": "2af725e96a70df93d2322c29ad1809a0e47c6944", "473": "3e5d1b3b2b6242526b48c1d0f8d0aa3fe5adced4"}, "revision_to_date": {"462": 1764251399000, "473": 1764255500000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Xeon(R) Silver 4210 CPU @ 2.20GHz"], "machine": ["lxd110h17"], "num_cpu": ["40"], "os": ["Linux 4.15.0-213-generic"], "ram": ["97599028"], "python": ["/opt/miniforge/envs/casa6/bin/python"], "branch": ["master-dev"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Xeon(R) Silver 4210 CPU @ 2.20GHz", "machine": "lxd110h17", "num_cpu": "40", "os": "Linux 4.15.0-213-generic", "ram": "97599028", "python": "/opt/miniforge/envs/casa6/bin/python", "branch": "master-dev"}], "benchmarks": {"bench_calibration.TimeApplyCal.time_applycal_single_table": {"code": "class TimeApplyCal:\n    def time_applycal_single_table(self):\n        \"\"\"Time applying single calibration table.\"\"\"\n        from casatasks import applycal\n    \n        applycal(\n            vis=str(self.work_ms),\n            field=\"0\",  # Single field only\n            gaintable=[str(self.caltable)],\n            applymode=\"calflag\",\n        )\n\n    def setup(self):\n        \"\"\"Prepare test MS with calibration table.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_apply_{self.test_ms.name}\"\n        self.caltable = SCRATCH_DIR / \"bench_apply.gcal\"\n    \n        if not self.work_ms.exists():\n            shutil.copytree(self.test_ms, self.work_ms)\n    \n        # Create a simple gain table if needed\n        if not self.caltable.exists():\n            from casatasks import gaincal\n            gaincal(\n                vis=str(self.work_ms),\n                caltable=str(self.caltable),\n                field=\"0\",\n                refant=\"103\",\n                solint=\"inf\",\n                gaintype=\"G\",\n                calmode=\"ap\",\n                minsnr=1.0,\n            )", "min_run_count": 2, "name": "bench_calibration.TimeApplyCal.time_applycal_single_table", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 180, "type": "time", "unit": "seconds", "version": "a0978ad070c9f3e8cf19ac8811518247100ec00507fb2eac5ba668220f2a8ae1", "warmup_time": -1}, "bench_calibration.TimeBandpassSolve.time_bandpass_single_field": {"code": "class TimeBandpassSolve:\n    def time_bandpass_single_field(self):\n        \"\"\"Time bandpass solve on single field.\"\"\"\n        from casatasks import bandpass\n    \n        bandpass(\n            vis=str(self.work_ms),\n            caltable=str(self.caltable),\n            field=self.field,\n            refant=self.refant,\n            solint=\"inf\",\n            combine=\"scan\",\n            minsnr=3.0,\n        )\n\n    def setup(self):\n        \"\"\"Prepare test MS and working directory.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_bp_{self.test_ms.name}\"\n        self.caltable = SCRATCH_DIR / \"bench_bp.bcal\"\n    \n        # Skip setup if cached copy exists\n        if not self.work_ms.exists():\n            shutil.copytree(self.test_ms, self.work_ms)\n    \n        if self.caltable.exists():\n            shutil.rmtree(self.caltable)\n    \n        self.refant = \"103\"\n        self.field = \"0\"", "min_run_count": 2, "name": "bench_calibration.TimeBandpassSolve.time_bandpass_single_field", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 180, "type": "time", "unit": "seconds", "version": "00ea0c2e2c8f74e76ff50248088fce708573f181943510812f24180d75584bcb", "warmup_time": -1}, "bench_calibration.TimeCalibrationImport.time_import_calibration_module": {"code": "class TimeCalibrationImport:\n    def time_import_calibration_module(self):\n        \"\"\"Time importing the calibration module.\"\"\"\n        import sys\n    \n        # Force reimport\n        mods_to_remove = [k for k in sys.modules if k.startswith(\"dsa110_contimg.calibration\")]\n        for mod in mods_to_remove:\n            del sys.modules[mod]\n    \n        import dsa110_contimg.calibration.calibration  # noqa: F401", "min_run_count": 2, "name": "bench_calibration.TimeCalibrationImport.time_import_calibration_module", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60, "type": "time", "unit": "seconds", "version": "2cbfa3a4981a5f66941681a9a17f0766507dd64c123fdbd201483cfeab4451c2", "warmup_time": -1}, "bench_calibration.TimeCalibrationImport.time_import_casa_tasks": {"code": "class TimeCalibrationImport:\n    def time_import_casa_tasks(self):\n        \"\"\"Time importing casatasks.\"\"\"\n        import sys\n    \n        mods_to_remove = [k for k in sys.modules if k.startswith(\"casatasks\")]\n        for mod in mods_to_remove:\n            del sys.modules[mod]\n    \n        from casatasks import bandpass, gaincal, applycal  # noqa: F401", "min_run_count": 2, "name": "bench_calibration.TimeCalibrationImport.time_import_casa_tasks", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60, "type": "time", "unit": "seconds", "version": "961efd599e2b61f81fda9c1858446831163c7e7ff2b6b9bd2d5d29fdcf556da9", "warmup_time": -1}, "bench_calibration.TimeGainSolve.time_gaincal_single_field": {"code": "class TimeGainSolve:\n    def time_gaincal_single_field(self):\n        \"\"\"Time gain solve on single field.\"\"\"\n        from casatasks import gaincal\n    \n        gaincal(\n            vis=str(self.work_ms),\n            caltable=str(self.caltable),\n            field=self.field,\n            refant=self.refant,\n            solint=\"inf\",\n            gaintype=\"G\",\n            calmode=\"ap\",\n            minsnr=3.0,\n        )\n\n    def setup(self):\n        \"\"\"Prepare test MS.\"\"\"\n        self.test_ms = _find_test_ms()\n        if self.test_ms is None:\n            raise NotImplementedError(\"No test MS available\")\n    \n        SCRATCH_DIR.mkdir(parents=True, exist_ok=True)\n        self.work_ms = SCRATCH_DIR / f\"bench_gain_{self.test_ms.name}\"\n        self.caltable = SCRATCH_DIR / \"bench_gain.gcal\"\n    \n        if not self.work_ms.exists():\n            shutil.copytree(self.test_ms, self.work_ms)\n    \n        if self.caltable.exists():\n            shutil.rmtree(self.caltable)\n    \n        self.refant = \"103\"\n        self.field = \"0\"", "min_run_count": 2, "name": "bench_calibration.TimeGainSolve.time_gaincal_single_field", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 120, "type": "time", "unit": "seconds", "version": "e06134e031350b53117ef970a8f3b5959fbd96d644478e0bfc39f46b120dfb50", "warmup_time": -1}, "bench_conversion.TimeFullConversion.time_convert_subband_group": {"code": "class TimeFullConversion:\n    def time_convert_subband_group(self):\n        \"\"\"Time full subband group conversion from SSD.\"\"\"\n        from astropy import units as u\n        from astropy.time import Time\n    \n        from dsa110_contimg.conversion.strategies.hdf5_orchestrator import (\n            convert_subband_groups_to_ms,\n        )\n    \n        # Get timestamp from first file for time range\n        name = self.staged_files[0].name\n        timestamp = name.split(\"_sb\")[0]\n    \n        # Need start < end, add 1 second\n        t = Time(timestamp, format=\"isot\")\n        start_time = (t - 1 * u.s).isot\n        end_time = (t + 1 * u.s).isot\n    \n        convert_subband_groups_to_ms(\n            input_dir=str(self.staging_dir),\n            output_dir=str(self.output_dir),\n            start_time=start_time,\n            end_time=end_time,\n        )\n\n    def setup(self):\n        \"\"\"Stage HDF5 files to SSD and prepare output directory.\"\"\"\n        self.hdf5_files = _find_subband_group()\n        if self.hdf5_files is None:\n            raise NotImplementedError(\"No complete HDF5 subband group available\")\n    \n        # Stage input files to SSD\n        self.staging_dir = SCRATCH_DIR / \"hdf5_staged\"\n        self.staged_files = _stage_files_to_ssd(self.hdf5_files, self.staging_dir)\n    \n        # Output directory on SSD\n        self.output_dir = SCRATCH_DIR / \"ms_output\"\n        if self.output_dir.exists():\n            shutil.rmtree(self.output_dir)\n        self.output_dir.mkdir(parents=True)", "min_run_count": 2, "name": "bench_conversion.TimeFullConversion.time_convert_subband_group", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "619cdcf1a52464920dcb5478497e7b7c48c2b91b0a22c8c0c4458c5a34b620b0", "warmup_time": -1}, "bench_conversion.TimeUVDataLoad.time_load_four_subbands": {"code": "class TimeUVDataLoad:\n    def time_load_four_subbands(self):\n        \"\"\"Time loading and combining 4 subbands from SSD using pipeline function.\"\"\"\n        from dsa110_contimg.conversion.strategies.hdf5_orchestrator import (\n            _load_and_merge_subbands,\n        )\n    \n        _load_and_merge_subbands(\n            [str(f) for f in self.staged_files[:4]],\n            batch_size=4,\n        )\n\n    def setup(self):\n        \"\"\"Stage HDF5 files to SSD.\"\"\"\n        self.hdf5_files = _find_subband_group()\n        if self.hdf5_files is None:\n            raise NotImplementedError(\"No complete HDF5 subband group available\")\n    \n        # Stage files to SSD (like the real pipeline does)\n        self.staging_dir = SCRATCH_DIR / \"hdf5_staged\"\n        self.staged_files = _stage_files_to_ssd(self.hdf5_files, self.staging_dir)\n        self.single_file = self.staged_files[0]", "min_run_count": 2, "name": "bench_conversion.TimeUVDataLoad.time_load_four_subbands", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "42b1a5bf490f854eb33d8fd1870db4a2d194e9f73450b3336249795114ac8ddd", "warmup_time": -1}, "bench_conversion.TimeUVDataLoad.time_load_single_subband": {"code": "class TimeUVDataLoad:\n    def time_load_single_subband(self):\n        \"\"\"Time loading a single subband HDF5 file from SSD.\"\"\"\n        from pyuvdata import UVData\n    \n        uvd = UVData()\n        uvd.read(\n            str(self.single_file),\n            file_type=\"uvh5\",\n            run_check=False,\n            run_check_acceptability=False,\n            strict_uvw_antpos_check=False,\n        )\n\n    def setup(self):\n        \"\"\"Stage HDF5 files to SSD.\"\"\"\n        self.hdf5_files = _find_subband_group()\n        if self.hdf5_files is None:\n            raise NotImplementedError(\"No complete HDF5 subband group available\")\n    \n        # Stage files to SSD (like the real pipeline does)\n        self.staging_dir = SCRATCH_DIR / \"hdf5_staged\"\n        self.staged_files = _stage_files_to_ssd(self.hdf5_files, self.staging_dir)\n        self.single_file = self.staged_files[0]", "min_run_count": 2, "name": "bench_conversion.TimeUVDataLoad.time_load_single_subband", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "2e531edb018dae98177f96ca651b5f1437064e5808f474ed6359f08982c9d2ae", "warmup_time": -1}, "bench_flagging.TimeFlagRFI.time_flag_rfi": {"code": "class TimeFlagRFI:\n    def time_flag_rfi(self):\n        \"\"\"Time AOFlagger RFI flagging.\"\"\"\n        pass\n\n    def setup(self):\n        \"\"\"Skip by default - too slow.\"\"\"\n        raise NotImplementedError(\"AOFlagger benchmark disabled (takes 3+ min)\")", "min_run_count": 2, "name": "bench_flagging.TimeFlagRFI.time_flag_rfi", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "887284f5a1b6bc25be09d6ff41b09bfedb33c59668c65d54e596573c67c0ac89", "warmup_time": -1}, "bench_flagging.TimeFlagReset.time_reset_flags": {"code": "class TimeFlagReset:\n    def time_reset_flags(self):\n        \"\"\"Time flag reset using pipeline function.\"\"\"\n        from dsa110_contimg.calibration.flagging import reset_flags\n        reset_flags(str(self.work_ms))\n\n    def setup(self):\n        \"\"\"Get cached MS.\"\"\"\n        self.work_ms = _get_cached_ms(\"bench_reset\")\n        if self.work_ms is None:\n            raise NotImplementedError(\"No test MS available\")", "min_run_count": 2, "name": "bench_flagging.TimeFlagReset.time_reset_flags", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60, "type": "time", "unit": "seconds", "version": "d943fd1c5e33c4d22f16ec6e7d304b47bede54953b21081dcea6cf7cb630e54c", "warmup_time": -1}, "bench_flagging.TimeFlagZeros.time_flag_zeros": {"code": "class TimeFlagZeros:\n    def time_flag_zeros(self):\n        \"\"\"Time zero flagging using pipeline function.\"\"\"\n        from dsa110_contimg.calibration.flagging import flag_zeros\n        flag_zeros(str(self.work_ms))\n\n    def setup(self):\n        \"\"\"Get cached MS.\"\"\"\n        self.work_ms = _get_cached_ms(\"bench_zeros\")\n        if self.work_ms is None:\n            raise NotImplementedError(\"No test MS available\")", "min_run_count": 2, "name": "bench_flagging.TimeFlagZeros.time_flag_zeros", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 120, "type": "time", "unit": "seconds", "version": "356322785c1ebf6257174b258eb451264b13c32f1d9bed7e6af9018d25d1b474", "warmup_time": -1}, "bench_imaging.TimeCleanImaging.time_wsclean_clean": {"code": "class TimeCleanImaging:\n    def time_wsclean_clean(self):\n        pass\n\n    def setup(self):\n        raise NotImplementedError(_SKIP_REASON)", "min_run_count": 2, "name": "bench_imaging.TimeCleanImaging.time_wsclean_clean", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "3239bc6c6755ce87ca8a505e8989c422f3b751c66f4abd3e74d14251397c60f8", "warmup_time": -1}, "bench_imaging.TimeDirtyImaging.time_wsclean_dirty": {"code": "class TimeDirtyImaging:\n    def time_wsclean_dirty(self):\n        pass\n\n    def setup(self):\n        raise NotImplementedError(_SKIP_REASON)", "min_run_count": 2, "name": "bench_imaging.TimeDirtyImaging.time_wsclean_dirty", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "4c6733ca05e3e0c49ea9e360ec450e88277a9f72a252bf970c7fd6dca60c7f1c", "warmup_time": -1}}, "machines": {"lxd110h17": {"arch": "x86_64", "cpu": "Intel(R) Xeon(R) Silver 4210 CPU @ 2.20GHz", "machine": "lxd110h17", "num_cpu": "40", "os": "Linux 4.15.0-213-generic", "ram": "97599028", "version": 1}}, "tags": {}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}