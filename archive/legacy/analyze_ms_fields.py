#!/usr/bin/env python3
"""
Analyze MS field structure for DSA-110 pipeline validation.

This script examines how field names are handled for calibrator sources
and counts the number of fields in MS files generated by different approaches.
"""

import logging
import sys
from pathlib import Path
from typing import Optional, List, Dict, Any

def analyze_ms_field_structure(ms_path: str) -> Dict[str, Any]:
    """
    Analyze the field structure of a Measurement Set.
    
    Args:
        ms_path: Path to Measurement Set
        
    Returns:
        Dictionary with field analysis results
    """
    try:
        from casacore.tables import table
        import numpy as np
    except ImportError:
        print("ERROR: casacore not available. This analysis requires casa6 environment.")
        return {}
    
    results = {
        'ms_path': ms_path,
        'field_count': 0,
        'field_names': [],
        'field_ids': [],
        'phase_centers': [],
        'unique_field_ids_in_data': [],
        'observations_count': 0,
        'sources_count': 0,
        'calibrator_indicators': [],
        'errors': []
    }
    
    try:
        # Analyze FIELD table
        with table(f"{ms_path}::FIELD", readonly=True) as field_table:
            results['field_count'] = field_table.nrows()
            
            if results['field_count'] > 0:
                # Get field names
                results['field_names'] = field_table.getcol('NAME').tolist()
                
                # Get phase centers (RA, Dec in radians)
                phase_dirs = field_table.getcol('PHASE_DIR')  # Shape: (nfield, npoly, 2)
                for i in range(phase_dirs.shape[0]):
                    ra_rad = phase_dirs[i, 0, 0]
                    dec_rad = phase_dirs[i, 0, 1]
                    # Convert to degrees for readability
                    ra_deg = np.degrees(ra_rad)
                    dec_deg = np.degrees(dec_rad)
                    results['phase_centers'].append({
                        'field_id': i,
                        'ra_deg': ra_deg,
                        'dec_deg': dec_deg,
                        'ra_rad': ra_rad,
                        'dec_rad': dec_rad
                    })
                    
                results['field_ids'] = list(range(results['field_count']))
                
    except Exception as e:
        results['errors'].append(f"Error reading FIELD table: {e}")
    
    try:
        # Analyze which fields are actually used in the data
        with table(ms_path, readonly=True) as main_table:
            field_col = main_table.getcol('FIELD_ID')
            results['unique_field_ids_in_data'] = sorted(set(field_col.tolist()))
            
    except Exception as e:
        results['errors'].append(f"Error reading main table FIELD_ID: {e}")
    
    try:
        # Analyze OBSERVATION table
        with table(f"{ms_path}::OBSERVATION", readonly=True) as obs_table:
            results['observations_count'] = obs_table.nrows()
            
    except Exception as e:
        results['errors'].append(f"Error reading OBSERVATION table: {e}")
    
    try:
        # Analyze SOURCE table (if it exists)
        with table(f"{ms_path}::SOURCE", readonly=True) as source_table:
            results['sources_count'] = source_table.nrows()
            
    except Exception as e:
        # SOURCE table is optional
        results['sources_count'] = 0
    
    # Look for calibrator indicators in field names
    calibrator_patterns = ['3C', 'J', 'B', '0834', '1934', 'PKS', 'VIR', 'HER', 'CAL']
    for field_name in results['field_names']:
        for pattern in calibrator_patterns:
            if pattern.upper() in field_name.upper():
                results['calibrator_indicators'].append({
                    'field_name': field_name,
                    'pattern': pattern
                })
                break
                
    return results


def print_field_analysis(results: Dict[str, Any]) -> None:
    """Print formatted field analysis results."""
    
    print(f"\nüîç MS Field Structure Analysis")
    print(f"{'='*50}")
    print(f"MS Path: {results['ms_path']}")
    
    if results['errors']:
        print(f"\n‚ùå Errors:")
        for error in results['errors']:
            print(f"   {error}")
    
    print(f"\nüìä Field Summary:")
    print(f"   Total Fields: {results['field_count']}")
    print(f"   Field IDs in Data: {results['unique_field_ids_in_data']}")
    print(f"   Observations: {results['observations_count']}")
    print(f"   Sources: {results['sources_count']}")
    
    if results['field_names']:
        print(f"\nüìù Field Names:")
        for i, name in enumerate(results['field_names']):
            print(f"   Field {i}: '{name}'")
    
    if results['phase_centers']:
        print(f"\nüéØ Phase Centers:")
        for pc in results['phase_centers']:
            print(f"   Field {pc['field_id']}: RA={pc['ra_deg']:.6f}¬∞, Dec={pc['dec_deg']:.6f}¬∞")
    
    if results['calibrator_indicators']:
        print(f"\nüåü Potential Calibrator Fields:")
        for cal in results['calibrator_indicators']:
            print(f"   '{cal['field_name']}' (matches pattern: {cal['pattern']})")
    else:
        print(f"\nüåü No obvious calibrator patterns found in field names")


def check_calibrator_field_naming() -> None:
    """
    Check how calibrator field names are handled in the DSA-110 pipeline.
    """
    
    print("üîç Calibrator Field Naming Analysis")
    print("="*50)
    
    # Check the code for how field names are set
    analysis_points = [
        {
            'component': 'Direct Subband Writer',
            'file': 'src/dsa110_contimg/conversion/strategies/direct_subband.py',
            'field_naming': 'Uses "meridian_icrs" for shared phase center or basename(part_out_path) for per-subband',
            'line_ref': '~490'
        },
        {
            'component': 'UVH5 to MS Conversion', 
            'file': 'src/dsa110_contimg/conversion/uvh5_to_ms.py',
            'field_naming': 'Uses cat_name parameter in phase() call',
            'line_ref': '~357'
        },
        {
            'component': 'Calibrator MS Service',
            'file': 'src/dsa110_contimg/conversion/calibrator_ms_service.py', 
            'field_naming': 'Handles calibrator name lookup from catalogs',
            'line_ref': 'Throughout'
        }
    ]
    
    for point in analysis_points:
        print(f"\nüìç {point['component']}:")
        print(f"   File: {point['file']}")
        print(f"   Field Naming: {point['field_naming']}")
        print(f"   Reference: Line {point['line_ref']}")
    
    print(f"\nüéØ Key Findings:")
    print(f"   1. Direct-subband approach uses generic names ('meridian_icrs' or subband-specific)")
    print(f"   2. Field names are NOT automatically updated based on calibrator source detection")
    print(f"   3. Calibrator information is tracked separately in streaming_converter (has_calibrator, calibrators columns)")
    print(f"   4. Actual calibrator names would need to be set explicitly during conversion")
    
    print(f"\nüí° Recommendations:")
    print(f"   1. Add calibrator name detection and field name updating in conversion workflow")
    print(f"   2. Use catalog lookup results to set meaningful field names")
    print(f"   3. Ensure field names match expected calibrator names for CASA calibration tasks")


def count_fields_in_sample_ms() -> None:
    """
    Count fields in sample MS files to understand typical field structure.
    """
    
    print("\nüî¢ Expected Field Count Analysis")
    print("="*40)
    
    print("Based on DSA-110 pipeline architecture:")
    print("   ‚Ä¢ Direct-subband approach: Creates per-subband MS files, then concatenates")
    print("   ‚Ä¢ Each subband gets same phase center (meridian_icrs) OR unique phase center")
    print("   ‚Ä¢ CASA concat merges fields if they have identical phase centers")
    print("   ‚Ä¢ Result: Usually 1 field (if shared phase center) or N fields (if unique per subband)")
    
    print("\nField count scenarios:")
    print("   1. Shared phase center: 1 field total (recommended)")
    print("   2. Per-subband phase centers: Up to 16 fields (one per subband)")
    print("   3. Calibrator vs target: Could have 2+ fields if different sources")
    
    print("\nCurrent implementation analysis:")
    print("   ‚Ä¢ direct_subband.py uses shared phase center by default (line ~489)")
    print("   ‚Ä¢ This should result in 1 field in the final concatenated MS")
    print("   ‚Ä¢ Field name will be 'meridian_icrs' (generic, not calibrator-specific)")


def main():
    """Main analysis function."""
    
    print("üî¨ DSA-110 MS Field Structure Analysis")
    print("="*60)
    
    # Check if MS path provided as argument
    if len(sys.argv) > 1:
        ms_path = sys.argv[1]
        print(f"Analyzing provided MS: {ms_path}")
        
        if Path(ms_path).exists():
            results = analyze_ms_field_structure(ms_path)
            print_field_analysis(results)
        else:
            print(f"ERROR: MS path does not exist: {ms_path}")
    else:
        print("No MS path provided - showing theoretical analysis")
    
    # Show calibrator field naming analysis
    check_calibrator_field_naming()
    
    # Show expected field count analysis
    count_fields_in_sample_ms()
    
    print(f"\nüìã Summary of Questions:")
    print(f"1. ‚ùì Field name updates for calibrators: NO - not automatically updated")
    print(f"2. ‚ùì Field count in direct-subband MS: Usually 1 (shared phase center)")
    print(f"3. üí° Recommendation: Add calibrator name detection and field name setting")


if __name__ == "__main__":
    main()